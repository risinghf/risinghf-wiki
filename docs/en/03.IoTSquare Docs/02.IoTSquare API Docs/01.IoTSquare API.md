---
title: IoTSquare API
date: 2022-04-15 14:28:36
permalink: /03/02/01/
---
# IoTSquare API

::: warning

This document describes the interface invocation method for the RisingHF IoTSqaure server and the custom application server, IoTSqaure provides data push and data delivery based on the HTTP protocol, using JSON to encode data

Refer to https://www.json.org/ for definitions of the json format

:::

## 1 Data Push

### 1.1 Push Link
Data push includes gateway heartbeat status push, gateway online/offline push, device join push, and application layer uplink data push,

The IoTSqaure configures the push link by application, and the data of all devices under the same application is pushed to the user-configured URL. Data push uses POST method, which automatically adopt the HTTPS/HTTP protocol based on user-configured link

User need to provide a URL link, for example:

```
https://test.risinghf.com
```

The IoTSqaure adds a path after the link, corresponding to different data formats and pushes, for example:

**Join Message:**

```
https://test.risinghf.com/join
```

**Application Layer Data Uplink:**

```
https://test.risinghf.com/uplink
```

**Gateway heartbeat status:**
```
https://test.risinghf.com/gwstat
```
**Gateway online/offline:**
```
https://test.risinghf.com/gwconnection
```

### 1.2 Request Header

IoTSqaure supports custom request header information, user can set token or user information in the request header and send it along with the data push, for example:

The user configures the contents of the Token request header field in the IoTSqaure as **ImsIuxj+Dg0/ClYJ9vdqYw==**

The token is directly obtained in the received request header, and the following is an example of the received request header.

```
Content-Type: application/json
Accept-Encoding: gzip
User-Agent: Go-http-client/1.1
Content-Length: 286
Token: ImsIuxj+Dg0/ClYJ9vdqYw==
```

### 1.3 Data Format

IoTSqaure uses a predetermined data format, which depends on the packet type, the following fields are fixedly sent:

```
{
    "devEUI": "574abd9100390397",
    "appID": 2,
    "time": 1543227536125,
    "type": "uplink",
    "data": object
}
```

**Field Parsing**

| Field Name | Type   | Description                                                  |
| ---------- | ------ | ------------------------------------------------------------ |
| **devEUI** | string | 16-byte hex string, device unique identifier                  |
| **appID**  | int64  | application ID to which the device belongs                   |
| **time**   | int64  | unix timestamp in milliseconds, 1543227536125 means UTC time 2018/11/26 10:18:56.125 |
| **type**   | string | packet type, there are currently two types of packet, join and uplink |
| **data**   | object | content corresponding to the packet type                     |

### 1.4 Join Message

The following is an example of a Join message:

```
{
    "devEUI": "574abd9100390397",
    "appID": 2,
    "type": "join",
    "time": 1543227536125,
    "data": {
        "devAddr": "00cc8f13"
    }
}
```

**Field Parsing**

| Field Name  | Type       | Description                      |
| ----------- | ---------- | -------------------------------- |
| **devAddr** | **string** | 8-byte hex string, device address |

::: warning

+ CS can receive JOIN message push only when the OTAA device join successfully. After registering to IoTSqaure, the ABP device can directly uplink data without join.
+ The JOIN message push time of the IoTSqaure is: After the device join successfully, the server receives the first frame data uplink of the device.
+ Since the JOIN ACCEPT response may be environmentally interferenced and cannot be received by the device, the current design can filter invalid JOIN information. When the cloud user receives the JOIN message push, it can determine the remote device's successful join.

:::

### 1.5 Application Layer Data Uplink

The following is an example of an application layer data uplink:

```
{
    "devEUI": "574abd9100390397",
    "appID": 2,
    "type": "uplink",
    "time": 1544078777092,
    "data": {
        "gwid": "b827ebfffe9aae48",
        "rssi": -27,
        "snr": 8.5,
        "freq": 868.1,
        "dr": 0,
        "adr": true,
        "class": "A",
        "fCnt": 0,
        "fPort": 8,
        "confirmed": true,
        "data": "ABEiM0Q=",
        "gws": [{
            "id": "b827ebfffe9aae48",
            "rssi": -27,
            "snr": 8.5
        }, {
            "id": "b827ebfffe9f0e77",
            "rssi": -40,
            "snr": 3.5
        }]
    }
}
```

**Field Parsing**

| Field Name    | Type   | Description                                                  |
| ------------- | ------ | ------------------------------------------------------------ |
| **gwid**      | string | 16-byte hexadecimal string, gateway unique identifier, composed of gateway mac address filled with fffe |
| **rssi**      | float  | the received signal strength is generated by the gateway, when multiple gateways receive the signal, the gateway with the strongest signal is taken, the value ranges from -150 to 30, the larger the value, the stronger the signal |
| **snr**       | float  | the signal-to-noise ratio is generated by the gateway, when multiple gateways receive the signal, the gateway with the best SNR is obtained, ranging from -30 to 30, the larger the value, the better the signal quality |
| **freq**      | float  | node transmission frequency                                  |
| **dr**        | int    | data rate, the higher the value, the higher the rate, the value range is 0~15 |
| **adr**       | bool   | the adr flag, if true, indicates that the node has enabled  ADR. |
| **class**     | string | The node supports three types: A, B, and C. The Class A and Class B devices correspond to the Class B flag in the LoraWAN data frame, and the Class C device corresponds to the node registration information. |
| **fCnt**      | uint32 | Node upstream frame counter, the OTAA node will be reset after join successfully, and the ABP node can be manually reset in the IoTSqaure. |
| **fPort**     | uint8  | Node port, when the FPort value is 0, FRMPayload only contains the MAC command, and 224~255 is reserved for the subsequent standardized application extension of LoraWAN. User available range 1~223 |
| **confirmed** | bool   | If true, it means that the data of this packet is the confirmed uplink. If it is false, it means that the data of this packet is the unconfirmed uplink. |
| **data**      | string | Node upstream data, using base64 encoding                    |
| **gws**       | array  | This node data transmission, list of all gateways that receive data sorted by signal strength and signal quality, The first gateway parameter corresponds to gwid, rssi, snr in the above fields. |

::: warning

+ When the uplink data of the node is successful, it may be received by multiple gateways. The gwid in the data field is the gateway information that corresponds to the best RSSI and SNR when receiving data. It is also the gateway for downlink routing in Class B and Class C modes.
+ The data raw data in the data field is a byte array. If 0011223344 is sent in hexadecimal on the node, the byte array is automatically converted to a printable base64 form string "ABEiM0Q=" by iotsquare before push data via http.

:::

### 1.6 Gateway Heartbeat Status 
**The following is an example of gateway online/offline push:**
```json
{
"gwID": "f04cd5fffe04490c",
"type": "gwconnection",
"time": 1669777246776,
"data": {
"gwName": "rxhf-test",
"gwType": "rhf2s208",
"enableClassB": true,
"enablePFW": false,
"region": "cn470",
"subnet": "ch_08-15",
"online": true,
"mqtt": true,
"latitude": 0,
"longitude": 0,
"altitude": 0,
"_gpsTimeStatus": false,
"_pktfwdStatus": true,
"_temperature": 34.81,
"_loadAverage": [0, 0, 0],
"_ramUsage": 41.61327,
"_rootPartitionUsage": 16.54671,
"_logPartitionUsage": 47.51172,
"_txPower": 27,
"_PowerState": false,
"_BatteryState": false,
"_BatteryLevel": 0,
"_BatteryVoltage": 0,
"_PublicIP": "192.168.0.76",
"_IntranetIP": "192.168.0.76",
"_ConnectMode": "eth0",
"_ETH_State": false,
"_PPP_State": false,
"_APN": "",
"_MODE": "",
"_RSSI": 0,
"_RSRP": 0,
"_RSRQ": 0,
"_SNR": 0,
"_IMSI": "",
"_CELLID": "",
"_LACID": "",
"_IMEI": "",
"_ICCID": "",
"_CNT": 344,
"_Subtype": "RHF2S208HBH8-470",
"_NetworkDelay": 0,
"_FirmwareDate": "2022-04-02",
"_FirmwareVersion": "3.0.0",
"_HardwareVersion": "3.0",
"_KernelVersion": "3.0",
"_SDKVersion": "3.4.9-3701104",
"_PktfwdVersion": "0.2.2 2022-03-31T05:35:03",
"configUpdateFlag": false,
"rstSrc": 0
}
}
```
#### 1. Push Gateway Fields

|Field Name|Type|Description|
| ------------- | -------- | ------------------------------------------------------------ |
|GwName|string| Gateway name|
|GwType|string| Gateway type|
|Region|string| Gateway region|
|Subnet|string| The subnet of the gateway|
|Online|bool| Whether the gateway is online, NS will judge the online status of the gateway by combining the MQTT mechanism and active detection of the server.Push will be generated when the status changes|
|EnableClassB|bool| Whether to enable ClassB support. The default value of Qingniao Gateway is false|
|enablePFW|bool| Whether to enable pktfwd, the default value of Qingniao Gateway is true|
|Mqtt|bool| Whether the gateway accesses NS in MQTT mode. The default value of Qingniao gateway is true|
|Altitude|float| Altitude, requires a gateway with GPS|
|Latitude|float| Latitude, requires a gateway with GPS|
|Longitude|float| Longitude, requires a gateway with GPS|
|_ GpsTimeStatus|bool| GPS time synchronization status, true means synchronized, false means not synchronized Generate push when the status changes|
|_ PktfwdStatus|bool| pktfwd status: true indicates online, false indicates offline Update once per heartbeat|
|_ temperature|float| 36.5 indicates 36.5 ℃ Update once per heartbeat|
|_ RamUsage|float| Memory usage, 17.63 means 17.63% Update once per heartbeat|
|_ LoadAverage|[3] float| System load. 0.35, 0.1, and 0.05 represent the system load in the last 1 minute, 5 minutes, and 15 minutes, respectively Update once per heartbeat|
|_ RamUsage|float| Memory usage, 17.63 means 17.63% Update once per heartbeat|
|_ rootPartitionUsage|float| The root partition utilization rate is 72.8% Update once per heartbeat|
|_ LogPartitionUsage|float| The log partition usage rate is 85.8% Update once per heartbeat|
|_ TxPower|int| downlink transmission power, 23 represents 23dBm|
|_ PowerState|bool| Main power state. true indicates that the main power is normal, and false indicates that the main power is faulty Update once per heartbeat|
|_ BatteryState|bool| Battery status. True indicates that the battery is normal, and false indicates that the battery is faulty Update once per heartbeat|
|_ BatteryLevel|uint8| electricity percentage, 80 means 80% electricity Update once per heartbeat|
|_ BatteryVoltage|float| Battery voltage, 9.12 represents 9.12V Update once per heartbeat|
|_ PublicIP|string| Public IP|
|_ Intranet IP|string| Intranet IP|
|_ ConnectMode|string| Connection mode,eth0: Ethernet,ppp0: 4G Update when connection status changes|
|_ ETH_ State|bool| Ethernet connection status, true indicates connected, false indicates disconnected Update once per heartbeat|
|_ PPP_ State|bool| 4G connection state. True indicates connected, and false indicates disconnected Update once per heartbeat|
|_ APN|string| APN. When the connection mode is 4G, it can beCMNETorCTNET. When using Ethernet communication, it is an empty string|
|_ RSSI|float| RSSI, - 38.3 means - 38.3 dBm Update once per heartbeat|
|_ RSRP|float| RSRP, - 32.0 means - 32.0dBm Update once per heartbeat|
|_ RSRQ|float| RSRQ, - 10.5 means - 10.5dB Update once per heartbeat|
|_ SNR|float| Signal to noise ratio, - 20.0 means - 20.0dB Update once per heartbeat|
|_ IMSI|string| International mobile subscriber identification code, composed of MCC/MNC/MSIN|
|_ CELLID|string|CELL ID|
|_ LACID|string|LAC ID|
|_ IMEI|string| Equipment ID|
|_ ICCID|string| SIM card number|
|_ CNT|uint32| Counter, value range 0~4294967295, stored on the gateway. The gateway adds 1 for each heartbeat or status change sent by the gateway, and returns to zero in case of overflow, gateway restart, and software crash|
|_ Subtype|string| gateway sub model|
|_ NetworkDelay|float| Network delay, 100.8 means 100.8 milliseconds|
|_ FirmwareDate|string| Firmware date|
|_ FirmwareVersion|string| Firmware Version|
|_ HardwareVersion|string| Hardware version|
|_ KernelVersion|string| Kernel Version|
|_ SDK Version|string| SDK Version|
|_ PktfwdVersion|string| Pktfwd Version|

#### 2. Temperature and battery voltage

|Field Name|Type|Description|
| ------------- | -------- | ------------------------------------------------------------ |
|_ PowerState|bool| Main power state. True indicates that the main power is normal, and false indicates that the main power is faulty The gateway is updated once per heartbeat|
|_ BatteryState|bool| Battery status. True indicates that the battery is normal, and false indicates that the battery is faulty The gateway is updated once per heartbeat|
|_ BatteryLevel|uint8| electricity percentage, 80 means 80% electricity The gateway is updated once per heartbeat|
|_ BatteryVoltage|float| Battery voltage, 9.12 represents 9.12V The gateway is updated once per heartbeat|
#### 3. Network information

|Field Name|Type|Description|
| ------------- | -------- | ------------------------------------------------------------ |
|_ ConnectMode|string| Connection mode,eth0: Ethernet,ppp0: 4G Update when connection status changes|
|_ ETH_ State|bool| Ethernet connection status, true indicates connected, false indicates disconnected Update once per heartbeat|
|_ PPP_ State|bool| 4G connection state. True indicates connected, and false indicates disconnected Update once per heartbeat|
|_ APN|string| APN. When the connection mode is 4G, it can beCMNETorCTNET. When using Ethernet communication, it is an empty string|
|_ MODE|string| MODE, dial system, generally GSM/WCDMA/TD-SCDMA/LTE system|
|_ RSSI|float| RSSI, - 38.3 means - 38.3 dBm Update once per heartbeat|
|_ RSRP|float|R

### 1.7 Gateway online/offline push
**For data structure type, refer to 1.6 Gateway Heartbeat Status Push**

## 2 Data Downlink

### 2.1 About The Concept of Data Downlink

The operating modes of the LoraWAN node has A, B, and C, the node can work in the AB or AC state at the same time, for data delivery:

+ A mode requires uplink data to carry data downlink, so data cannot be actively sent from the server.
+ B mode can actively send data through Beacon timing.
+ C mode can actively send data as soon as possible with the least delay, but need to avoid the two receiving windows of A mode.

Therefore, the above three modes all use the queue to schedule data delivery. According to the first-in-first-out rule, the delivered data is first queued, and then dispatched according to the node mode. The delivery operation or the call interface operation succeeds, indicating that the data has been enqueued, which is not already sent to the node.

### 2.2 Data Downlink Interface

When users need to send application layer data to a node, they can directly operate on the IoTSqaure web page or use an HTTP request. The following is the call interface description.

1. Interface Address: https://cloud.iotsquare.xyz/openapi/device/downlink/create

2. Request Method: POST

3. API Token Configuration

   + The user can find the API Token field in the user details in the IoTSqaure backend, for example: **tl1lzqMMueQUVI+Eyotbnw==**
   + When the user invokes the interface, the x-access-token field value in the request header needs to be set to **tl1lzqMMueQUVI+Eyotbnw==**, and the token is sent along with the request

4. Downlink Parameter Format

   ```
   {
       "devEUI": "574abd9100390397",
       "confirmed": false,
       "fPort": 8,
       "data": "ABEiM0Q="
   }
   ```

   **Field Parsing**

   | Feild Name    | Type   | Description                                                  |
   | ------------- | ------ | ------------------------------------------------------------ |
   | **devEUI**    | string | 16-byte hex string, device unique identifier                  |
   | **confirmed** | bool   | optional, if not set, the default is false, Use unconfirmed downlink. If true, use confirmed downlink |
   | **fPort**     | uint8  | node port, user available range 1~223                        |
   | **data**      | string | node downstream data, using base64 encoding                  |

5. Response Parameter Format

   The following is the response when the interface call succeeds:

   ```
   {
       "code": 0,
       "msg": "ok",
       "fCnt": 233
   }
   ```

   **Field Parsing**

   | Field Name | Type   | Description                                            |
   | ---------- | ------ | ------------------------------------------------------ |
   | **code**   | int    | response code, 0 means the data is successfully queued |
   | **msg**    | string | response message                                       |
   | **fCnt**   | uint32 | downstream fCnt counter                                |

   If the call is unsuccessful, the code is not 0, the specific meaning is as follows:

   | **code** | Description                                                 |
   | -------- | ----------------------------------------------------------- |
   | **1001** | IoTSqaure internal network is busy, you can try again later |
   | **1006** | the downlink parameter is empty                             |
   | **1007** | downstream parameter format error                           |
   | **4001** | node does not exist                                         |

::: warning

   data is a byte array. If 0011223344 (hex format) is to be sent from the  application server, it should be encoded as  ABEiM0Q= using base64 encoder first. If the delivery is successful, the application layer data received by the node is also 0011223344, and the byte array is serialized to json field.

:::

## 3 MQTT Publish

### 3.1 Publish（data downlink）

The operating modes of the LoraWAN node has A, B, and C, the node can work in the AB or AC state at the same time, for data delivery:

- A mode requires uplink data to carry data downlink, so data cannot be actively sent from the server.
- B mode can actively send data through Beacon timing.
- C mode can actively send data as soon as possible with the least delay, but need to avoid the two receiving windows of A mode.

Therefore, the above three modes all use the queue to schedule data delivery. According to the first-in-first-out rule, the delivered data is first queued, and then dispatched according to the node mode. The delivery operation or the call interface operation succeeds, indicating that the data has been enqueued, which is not already sent to the node.

### 3.2 Publish Topic

1. topic rules

   * publish topic：user/{{**uid**}}/device/{{**device_eui**}}/downlink

2. Complete TOPIC example：

   ```json
   user/1/device/474abd91003xxxx/downlink
   ```

   {{**device_eui**}} is the device ID，{{**uid**}} is the user ID。For specific data, you can view the corresponding data of the developer in the user management in the `iotsquare` platform。

### 3.3 Data Publish

When users need to deliver the application layer data to the node, they can directly operate on the IoTSqaure background page, or use MQTT to request the call. The following is the call interface description.。

1. Request Method：MQTT

2. API Token Configuration

   - The user can find the API Token field in the user details in the IoTSqaure backend, for example: **tl1lzqMMueQUVI+Eyotbnw==**
   - When calling the interface, the user needs to set the **token** field value in the request body to **tl1lzqMMueQUVI+Eyotbnw==**, and the token is sent with the request

3. Complete example of publishing topic:

   ```json
   {
     "token": "tl1lzqMMueQUVI+Eyotbnw==",
     "params": {
       "DevEUI": "474abd910039xxxxx",
       "fPort": 2,
       "data": "ABEiM0Q=",
       "confirmed": false
     }
   }
   ```

   **Field Parsing**

   | **字段名** | **类型** | **描述** |
   | ---------- | -------- | -------- |
   | **token**  | string   | token    |
   | **params** | params   | param    |

   **Params**

   | Feild    Name | Type   | Description                                                  |
   | ------------- | ------ | ------------------------------------------------------------ |
   | **devEUI**    | string | 16-byte hex string, device unique identifier                 |
   | **confirmed** | bool   | optional, if not set, the default is false, Use unconfirmed downlink. If true, use confirmed downlink |
   | **fPort**     | uint8  | node port, user available range 1~223                        |
   | **data**      | string | node downstream data, using base64 encoding                  |

   In practical applications, the above `JSON` data needs to be serialized and encoded through `proto buffer` and sent.



   The format of `proto buffer` is as follows:

   ```protobuf
   message DLParams{
       string DevEUI = 1;
       int32 FPort = 2;
       bytes Data = 3;
       bool Confirm = 4;
   }

   message DeviceDownlink {
       string Token = 1;
       DLParams Params = 2;
   }
   ```

::: warning

   data is a byte array. If 0011223344 (hex format) is to be sent from the application server, it should be encoded as ABEiM0Q= using base64 encoder first. If the delivery is successful, the application layer data received by the node is also 0011223344, and the byte array is serialized to json field.

:::

## 4 MQTT Subscribe

### 4.1 Subscribe（data uplink）

After the topic is published, all clients subscribing to the topic will receive real-time data delivered by the server.

### 4.2 Subscribe Topic

1. topic rules

   * subscribe topic：user/{{**uid**}}/device/{{**device_eui**}}/uplink

2. Complete TOPIC example：：

   ```json
   user/1/device/474abd91003xxxx/uplink
   ```

   {{**device_eui**}} is the device ID, and {{**uid**}} is the user ID. You can view the corresponding data of the developer in the user management in the `iotsquare` platform. The data is encoded using `proto buffer` serialization.

### 4.3 Data Format

The developer MQTT client will get the complete `JSON` after going through the `proto buffer` deserialization step.

The format of `proto buffer` is as follows:

```protobuf
message RXInfoSimplified {
    string ID = 1;
    int32 RSSI = 2;
    float SNR = 3;
}

message DeviceUplink {
    string DevEUI = 1;
    int64 ApplicationID = 2;
    string MsgType = 3;
    int64 Timestamp = 4;
    string GatewayID = 5;
    int32 RSSI = 6;
    float SNR = 7;
    float Frequency = 8;
    int32 DataRate = 9;
    bool ADR = 10;
    string Class = 11;
    uint32 FCnt = 12;
    int32 FPort = 13;
    bool Confirm = 14;
    bytes Data = 15;
    repeated RXInfoSimplified Gateways = 16;
}
```

The `JSON format` is as follows:

```json
{
	"DevEUI": "474abd9100390037",
	"ApplicationID": 211,
	"MsgType": "uplink",
	"Timestamp": 1593760116946,
	"GatewayID": "8cf957fffe8002d1",
	"RSSI": -5,
	"SNR": 11,
	"Frequency": 470.7,
	"DataRate": 4,
	"ADR": true,
	"Class": "C",
	"FCnt": 11,
	"FPort": 8,
	"Confirm": true,
	"Data": "ABEiM0Q=",
	"Gateways": [{
		"ID": "8cf957fffe8002d1",
		"RSSI": -5,
		"SNR": 11
	}]
}
```

Among them, the `Data` field is the actual data after `base64Encode`.


## 5. MQTT server link configuration

The mqtt connection parameters are as follows:

```json
MQTT Broker URL：tls://cloud.iotsquare.xyz:2883
MQTT Name：Sha8Hz7biot
MQTT Password：xrPB5jLplALYfJ3Cg
CA Certificate File: `caCert.pem` provided by RisingHF
```

Users can find the above-mentioned related fields in the user details of the IoTSqaure background, and `caCert.pem` provided by RisingHF.

### 5.1 MQTT service interaction

ioTSquare provides real-time data interaction capability in the form of MQTT. Mainly used in the interaction of upstream and downstream data, the specific processing flow is shown in the following figure:

![mqtt-sdk-en](https://wiki.risinghf.com/upload/img/1f96b8f2c294d013ac0a9dfce469098f.png)

### 5.2 MQTT Client SDK

RisingHF provides the MQTT client SDK in golang by default, which is only for development and debugging reference, and should not be used directly in the actual production environment.

[MQTT Client With Golang](https://risinghf-helium.s3.amazonaws.com/2022-04-15/780278579c820fcc9a36958a5ad56ddf.gz)
