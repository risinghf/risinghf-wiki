---
title: RHF0M302-xxxB miniPCIE Gateway Module Development Manual
date: 2023-03-01 14:00:00
permalink: /01/01/08/01/
---

## 1 Introduction

RHF0M302B 8-channel LoRa gateway module is a high-performance small-size module with built-in Semtech's LoRa/LoRaWAN gateway chip SX1302. Dedicated to wireless sensing, automatic meters and other IoT applications, the RHF0M302 8-channel LoRa gateway module can help users quickly design their own LoRa/LoRaWAN gateways. The working frequency bands supported by the gateway module are: 470 ~ 510MHz, 868MHz and 915MHz, meeting the needs of users in various regions.

In order to facilitate teaching and lower the threshold for using the RHF0M302B module, this document uses the Raspberry Pi as the main control to show how to use the RHF0M302B module.

Since this document does not teach users how to use the Raspberry Pi, users should find information and install the necessary tools and export the spi interface by themselves.

Installation tools: git, make

Export spi interface: /dev/spidev0.0, /dev/spidev0.1 (If the user does not use the channel monitoring and noise floor scanning function, the /dev/spidev0.1 interface is not required)

## 2 Adapt sx1302_hal/packet_forwarder

The sx1302 driver library includes both sx1302_hal and packet forwarder, so just compile sx1302_hal.

### 2.1 download

Open the Raspberry Pi command terminal and use the git tool to download the sx1302 driver library.

```
$> git clone https://github.com/Lora-net/sx1302_hal.git
```

### 2.3 patch

After the download is complete, enter the source code root directory of sx1302_hal and apply the following patch. The patch is for version V2.1.0 (commit 4b42025d1751e04632c0b04160e0d29dbbb222a5)

```
diff --git a/libloragw/src/loragw_hal.c b/libloragw/src/loragw_hal.c
index ffc8ec0..607e16f 100644
--- a/libloragw/src/loragw_hal.c
+++ b/libloragw/src/loragw_hal.c
@@ -1093,6 +1093,7 @@ int lgw_start(void) {
     dbg_init_random();
 
     if (CONTEXT_COM_TYPE == LGW_COM_SPI) {
+#ifdef TEMP
         /* Find the temperature sensor on the known supported ports */
         for (i = 0; i < (int)(sizeof I2C_PORT_TEMP_SENSOR); i++) {
             ts_addr = I2C_PORT_TEMP_SENSOR[i];
@@ -1116,9 +1117,10 @@ int lgw_start(void) {
             printf("ERROR: no temperature sensor found.\n");
             return LGW_HAL_ERROR;
         }
-
+#endif
         /* Configure ADC AD338R for full duplex (CN490 reference design) */
         if (CONTEXT_BOARD.full_duplex == true) {
+#ifdef ADC
             err = i2c_linuxdev_open(I2C_DEVICE, I2C_PORT_DAC_AD5338R, &ad_fd);
             if (err != LGW_I2C_SUCCESS) {
                 printf("ERROR: failed to open I2C for ad5338r\n");
@@ -1141,6 +1143,7 @@ int lgw_start(void) {
                 return LGW_HAL_ERROR;
             }
             printf("INFO: AD5338R: Set DAC output to 0x%02X 0x%02X\n", (uint8_t)VOLTAGE2HEX_H(0), (uint8_t)VOLTAGE2HEX_L(0));
+#endif
         }
     }
 
@@ -1222,20 +1225,23 @@ int lgw_stop(void) {
     }
 
     if (CONTEXT_COM_TYPE == LGW_COM_SPI) {
+#ifdef TEMP
         DEBUG_MSG("INFO: Closing I2C for temperature sensor\n");
         x = i2c_linuxdev_close(ts_fd);
         if (x != 0) {
             printf("ERROR: failed to close I2C temperature sensor device (err=%i)\n", x);
             err = LGW_HAL_ERROR;
         }
-
+#endif
         if (CONTEXT_BOARD.full_duplex == true) {
+#ifdef ADC
             DEBUG_MSG("INFO: Closing I2C for AD5338R\n");
             x = i2c_linuxdev_close(ad_fd);
             if (x != 0) {
                 printf("ERROR: failed to close I2C AD5338R device (err=%i)\n", x);
                 err = LGW_HAL_ERROR;
             }
+#endif
         }
     }
 
@@ -1413,6 +1419,7 @@ int lgw_send(struct lgw_pkt_tx_s * pkt_data) {
 
     /* Set PA gain with AD5338R when using full duplex CN490 ref design */
     if (CONTEXT_BOARD.full_duplex == true) {
+#ifdef ADC
         uint8_t volt_val[AD5338R_CMD_SIZE] = {0x39, VOLTAGE2HEX_H(2.51), VOLTAGE2HEX_L(2.51)}; /* set to 2.51V */
         err = ad5338r_write(ad_fd, I2C_PORT_DAC_AD5338R, volt_val);
         if (err != LGW_I2C_SUCCESS) {
@@ -1420,6 +1427,7 @@ int lgw_send(struct lgw_pkt_tx_s * pkt_data) {
             return LGW_HAL_ERROR;
         }
         printf("INFO: AD5338R: Set DAC output to 0x%02X 0x%02X\n", (uint8_t)VOLTAGE2HEX_H(2.51), (uint8_t)VOLTAGE2HEX_L(2.51));
+#endif
     }
 
     /* Start Listen-Before-Talk */
@@ -1597,7 +1605,12 @@ int lgw_get_temperature(float* temperature) {
 
     switch (CONTEXT_COM_TYPE) {
         case LGW_COM_SPI:
+#ifdef TEMP
             err = stts751_get_temperature(ts_fd, ts_addr, temperature);
+#else
+            *temperature = 30.0;
+            err = 0;
+#endif
             break;
         case LGW_COM_USB:
             err = lgw_com_get_temperature(temperature);
diff --git a/tools/reset_lgw.sh b/tools/reset_lgw.sh
index b58f0e9..032f04d 100755
--- a/tools/reset_lgw.sh
+++ b/tools/reset_lgw.sh
@@ -12,10 +12,8 @@
 # GPIO mapping has to be adapted with HW
 #
 
-SX1302_RESET_PIN=23     # SX1302 reset
-SX1302_POWER_EN_PIN=18  # SX1302 power enable
-SX1261_RESET_PIN=22     # SX1261 reset (LBT / Spectral Scan)
-AD5338R_RESET_PIN=13    # AD5338R reset (full-duplex CN490 reference design)
+SX1302_RESET_PIN=75     # SX1302 reset
+SX1261_RESET_PIN=133    # SX1261 reset (LBT / Spectral Scan)
 
 WAIT_GPIO() {
     sleep 0.1
@@ -25,33 +23,18 @@ init() {
     # setup GPIOs
     echo "$SX1302_RESET_PIN" > /sys/class/gpio/export; WAIT_GPIO
     echo "$SX1261_RESET_PIN" > /sys/class/gpio/export; WAIT_GPIO
-    echo "$SX1302_POWER_EN_PIN" > /sys/class/gpio/export; WAIT_GPIO
-    echo "$AD5338R_RESET_PIN" > /sys/class/gpio/export; WAIT_GPIO
 
     # set GPIOs as output
     echo "out" > /sys/class/gpio/gpio$SX1302_RESET_PIN/direction; WAIT_GPIO
     echo "out" > /sys/class/gpio/gpio$SX1261_RESET_PIN/direction; WAIT_GPIO
-    echo "out" > /sys/class/gpio/gpio$SX1302_POWER_EN_PIN/direction; WAIT_GPIO
-    echo "out" > /sys/class/gpio/gpio$AD5338R_RESET_PIN/direction; WAIT_GPIO
 }
 
 reset() {
-    echo "CoreCell reset through GPIO$SX1302_RESET_PIN..."
-    echo "SX1261 reset through GPIO$SX1302_RESET_PIN..."
-    echo "CoreCell power enable through GPIO$SX1302_POWER_EN_PIN..."
-    echo "CoreCell ADC reset through GPIO$AD5338R_RESET_PIN..."
-
-    # write output for SX1302 CoreCell power_enable and reset
-    echo "1" > /sys/class/gpio/gpio$SX1302_POWER_EN_PIN/value; WAIT_GPIO
-
     echo "1" > /sys/class/gpio/gpio$SX1302_RESET_PIN/value; WAIT_GPIO
     echo "0" > /sys/class/gpio/gpio$SX1302_RESET_PIN/value; WAIT_GPIO
 
     echo "0" > /sys/class/gpio/gpio$SX1261_RESET_PIN/value; WAIT_GPIO
     echo "1" > /sys/class/gpio/gpio$SX1261_RESET_PIN/value; WAIT_GPIO
-
-    echo "0" > /sys/class/gpio/gpio$AD5338R_RESET_PIN/value; WAIT_GPIO
-    echo "1" > /sys/class/gpio/gpio$AD5338R_RESET_PIN/value; WAIT_GPIO
 }
 
 term() {
@@ -64,30 +47,18 @@ term() {
     then
         echo "$SX1261_RESET_PIN" > /sys/class/gpio/unexport; WAIT_GPIO
     fi
-    if [ -d /sys/class/gpio/gpio$SX1302_POWER_EN_PIN ]
-    then
-        echo "$SX1302_POWER_EN_PIN" > /sys/class/gpio/unexport; WAIT_GPIO
-    fi
-    if [ -d /sys/class/gpio/gpio$AD5338R_RESET_PIN ]
-    then
-        echo "$AD5338R_RESET_PIN" > /sys/class/gpio/unexport; WAIT_GPIO
-    fi
 }
 
 case "$1" in
-    start)
-    term # just in case
-    init
-    reset
-    ;;
     stop)
     reset
     term
     ;;
     *)
-    echo "Usage: $0 {start|stop}"
-    exit 1
+    term # just in case
+    init
+    reset
     ;;
 esac
 
-exit 0
\ No newline at end of file
+exit 0
```

**Note: `75` and `133` in `+SX1302_RESET_PIN=75` and `+SX1261_RESET_PIN=133` in the patch are the gpio ports connected to the modules `SX1302_RESET_HOST` and `SX1261_NRESET`, users need to modify it according to their own hardware .**

### 2.2 compile

Execute the compile command after patching.

```
$> make
```

After the compilation is successful, the user will get several binary files, among which the packet_forwarder/lora_pkt_fwd file is more important, which is the LoRa service program connected to the server.

### 2.4 Run packet_forwarder

Enter the packet_forwarder directory

```
$> cd packet_forwarder
```

Copy the reset script to the packet_forwarder directory

```
$> cp ../tools/reset_lgw.sh ./
```

Run lora_pkt_fwd. If the user uses the 470 module, use the `global_conf.json.sx1250.CN490` configuration file; if the 868 module, use the `global_conf.json.sx1250.EU868` configuration file; if the 915 module, use `global_conf .json.sx1250.US915` configuration file. Here we take the 470 module as an example.

```
./lora_pkt_fwd -c global_conf.json.sx1250.CN490
```

When the following information is output, it means that the module is working normally.

```
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
INFO: Configuring SX1250_0 in single input mode
INFO: Configuring SX1250_1 in single input mode
INFO: using legacy timestamp
INFO: LoRa Service modem: configuring preamble size to 8 symbols
ARB: dual demodulation disabled for all SF
INFO: [main] concentrator started, packet can now be received
INFO: concentrator EUI: 0x0016c001f1047d2e
```

## 3 Configuration file

### 3.1 Modify the configuration file

The following content adds a comment field, and users can modify it as needed. Other fields are not recommended to be modified unless the user is familiar with configuration files.

```json
{
    "SX130x_conf": {
        "com_type": "SPI",
        "com_path": "/dev/spidev0.0", /* communication path. Raspberry Pi uses /dev/spidev0.0. If the user uses other platforms, it needs to be adjusted according to the platform interface */
        "lorawan_public": true,
        "clksrc": 0,
        "antenna_gain": 0,
        "full_duplex": false, /* Whether to support full duplex. Currently RHF0M302B only releases half-duplex models, so the default value is false */
        "fine_timestamp": {
            "enable": false,
            "mode": "all_sf"
        },
        "sx1261_conf": {
            "spi_path": "/dev/spidev0.1", /* Noise floor scanning and channel listening communication path. Raspberry Pi uses /dev/spidev0.1. If the user uses other platforms, it needs to be adjusted according to the platform interface */
            "rssi_offset": -7,
            "spectral_scan": {
                "enable": false, /* Start noise scanning along with packet_forwarder, it is not started by default */
                "freq_start": 867100000, /* The starting frequency of noise scanning, unit: Hz */
                "nb_chan": 8, /* Noise scanning Channels (200kHz between each channel) */
                "nb_scan": 2000, /* Noise scanning points per frequency */
                "pace_s": 10 /* seconds between scans */
            },
            "lbt": {
                "enable": false, /* Channel monitoring is disabled by default. Note: After opening the channel monitoring, if the setting is improper, it may cause serious packet loss, or even fail to send downlink data packets */
                "rssi_target": -70, /* When it detects the surrounding signal interference >= -70dbm, it refuses to send downlink data packets, and users can make adjustments according to their own needs */
                "channels":[ /* freq_hz is the channel monitoring frequency point, the user can modify the value of freq_hz according to the needs. The maximum array is 16 */
                    { "freq_hz": 867100000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867300000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867500000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867700000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867900000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 868100000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 868300000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 868500000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 869525000, "bandwidth": 125000, "scan_time_us": 5000, "transmit_time_ms": 4000 },
                    { "freq_hz": 868300000, "bandwidth": 250000, "scan_time_us": 128,  "transmit_time_ms": 400 }
                ]
            }
        },
        "radio_0": {
            "enable": true,
            "type": "SX1250",
            "single_input_mode": true,
            "freq": 867500000, /* radio_0 center frequency point, combined with chan_multiSF_y to finally calculate 9 (8 adaptive channels and 1 LoRa standard channel) channel frequency points */
            "rssi_offset": -215.4,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": true,
            "tx_freq_min": 863000000,
            "tx_freq_max": 870000000,
            "tx_gain_lut":[
                {"rf_power": 12, "pa_gain": 1, "pwr_idx":  4},
                {"rf_power": 13, "pa_gain": 1, "pwr_idx":  6},
                {"rf_power": 14, "pa_gain": 1, "pwr_idx":  7},
                {"rf_power": 15, "pa_gain": 1, "pwr_idx":  8},
                {"rf_power": 16, "pa_gain": 1, "pwr_idx":  9},
                {"rf_power": 17, "pa_gain": 1, "pwr_idx": 11},
                {"rf_power": 18, "pa_gain": 1, "pwr_idx": 12},
                {"rf_power": 19, "pa_gain": 1, "pwr_idx": 14},
                {"rf_power": 20, "pa_gain": 1, "pwr_idx": 15},
                {"rf_power": 21, "pa_gain": 1, "pwr_idx": 16},
                {"rf_power": 22, "pa_gain": 1, "pwr_idx": 17},
                {"rf_power": 23, "pa_gain": 1, "pwr_idx": 18},
                {"rf_power": 24, "pa_gain": 1, "pwr_idx": 20},
                {"rf_power": 25, "pa_gain": 1, "pwr_idx": 20},
                {"rf_power": 26, "pa_gain": 1, "pwr_idx": 20},
                {"rf_power": 27, "pa_gain": 1, "pwr_idx": 20}
            ]
        },
        "radio_1": {
            "enable": true,
            "type": "SX1250",
            "single_input_mode": true,
            "freq": 868500000, /* radio_1 center frequency point, combined with chan_multiSF_y to finally calculate 9 (8 adaptive channels and 1 LoRa standard channel) channel frequency points */
            "rssi_offset": -215.4,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": false
        },
        "chan_multiSF_All": {"spreading_factor_enable": [ 5, 6, 7, 8, 9, 10, 11, 12 ]},
        /* Use radio_x center frequency point and chan_multiSF_y to calculate 9 channel frequency points, the calculation formula is radio_x.freq + chan_multiSF_y.if = y channel frequency point. For example, if enable of chan_multiSF_0 is true, the channel is enabled, and if radio is 1, it means to calculate the 0th channel frequency with the center frequency of radio_1. The final frequency of channel 0 is 868500000 + (-400000) = 868100000, and so on for other channels. Note: It is not recommended that users modify the contents of chan_multiSF_x, chan_Lora_std and chan_FSK */
        "chan_multiSF_0": { "enable": true, "radio": 1, "if": -400000 },
        "chan_multiSF_1": { "enable": true, "radio": 1, "if": -200000 },
        "chan_multiSF_2": { "enable": true, "radio": 1, "if": 0 },
        "chan_multiSF_3": { "enable": true, "radio": 0, "if": -400000 },
        "chan_multiSF_4": { "enable": true, "radio": 0, "if": -200000 },
        "chan_multiSF_5": { "enable": true, "radio": 0, "if": 0 },
        "chan_multiSF_6": { "enable": true, "radio": 0, "if": 200000 },
        "chan_multiSF_7": { "enable": true, "radio": 0, "if": 400000 },
        "chan_Lora_std":  { "enable": true, "radio": 1, "if": -200000, "bandwidth": 250000, "spread_factor": 7,
            "implicit_hdr": false, "implicit_payload_length": 17, "implicit_crc_en": false, "implicit_coderate": 1},
        "chan_FSK":       { "enable": true, "radio": 1, "if": 300000, "bandwidth": 125000, "datarate": 50000 }
    },

    "gateway_conf": {
        "gateway_ID": "AA555A0000000000", /* gateway_ID. User-defined 16 characters, as long as it is unique on the server */

        "server_address": "localhost", /* service address */
        "serv_port_up": 1730, /* server uplink port */
        "serv_port_down": 1730, /* server downlink port */

        "keepalive_interval": 10, /* Heartbeat interval, unit: second */
        "stat_interval": 30, /* Status packet reporting interval, unit: second */
        "push_timeout_ms": 100, /* Push timeout, unit: millisecond */
        "autoquit_threshold": 5, /* Cannot receive the number of server replies, automatically exit */

        "forward_crc_valid": true,
        "forward_crc_error": false,
        "forward_crc_disabled": false,

        "gps_tty_path": "/dev/ttyGPS", /* GPS path */

        "ref_latitude": 0.0,
        "ref_longitude": 0.0,
        "ref_altitude": 0,

        /* The following are beacon-related configurations, which are related to the LoRaWAN protocol. It is recommended that users familiarize themselves with the LoRaWAN protocol before modifying it. */
        "beacon_period": 128, /* Beacon time synchronization period, used to synchronize classB node time */
        "beacon_freq_hz": 869525000, /* Beacon frequency, unit: Hz */
        "beacon_freq_nb": 1, /* Beacon frequency downlink channel */
        "beacon_freq_step": 0, /* Beacon frequency step */
        "beacon_datarate": 9, /* Beacon rate. The parameter is: PingSlotDR.SpreadFactor */
        "beacon_bw_hz": 125000, /* Beacon bandwidth. The parameter is: PingSlotDR.Bandwidth */
        "beacon_power": 14, /* Beacon transmission power */
        "beacon_infodesc": 0 /* Beacon information description field */
    }
}
```

In order to make the RHF0M302B module perform better, this document provides an example of an optimized configuration file. It is recommended that users use the following configurations. If the user wants to modify the frequency point, he only needs to modify the two center frequencies `SX130x_conf.radio_0.freq` and `SX130x_conf.radio_1.freq`.

### 3.2 470 profile

```json
{
    "SX130x_conf": {
        "com_type": "SPI",
        "com_path": "/dev/spidev0.0",
        "lorawan_public": true,
        "clksrc": 0,
        "antenna_gain": 0, /* antenna gain, in dBi */
        "full_duplex": false,
        "fine_timestamp": {
            "enable": false,
            "mode": "all_sf" /* high_capacity or all_sf */
        },
        "sx1261_conf": {
            "spi_path": "/dev/spidev0.1",
            "rssi_offset": -17, /* dB */
            "spectral_scan": {
                "enable": false,
                "freq_start": 470300000,
                "nb_chan": 8,
                "nb_scan": 2000,
                "pace_s": 10
            },
            "lbt": {
                "enable": false /* LBT for 500 Khz channels is not supported */
            }
        },
        "radio_0": {
            "enable": true,
            "type": "SX1250",
            "single_input_mode": true,
            "freq": 470600000,
            "tx_freq_min": 470000000,
            "tx_freq_max": 510000000,
            "rssi_offset": -207.0,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": true,
            "tx_gain_lut":[
                {"rf_power": -6, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": -3, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power":  0, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power":  3, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power":  6, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 10, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 11, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 12, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 13, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 14, "pa_gain": 1, "pwr_idx":  2},
                {"rf_power": 16, "pa_gain": 1, "pwr_idx":  4},
                {"rf_power": 20, "pa_gain": 1, "pwr_idx":  8},
                {"rf_power": 23, "pa_gain": 1, "pwr_idx": 12},
                {"rf_power": 25, "pa_gain": 1, "pwr_idx": 16},
                {"rf_power": 26, "pa_gain": 1, "pwr_idx": 18},
                {"rf_power": 27, "pa_gain": 1, "pwr_idx": 18}
            ]
        },
        "radio_1": {
            "enable": true,
            "type": "SX1250",
            "single_input_mode": true,
            "freq": 471400000,
            "rssi_offset": -207.0,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": false
        },
        "chan_multiSF_All": {"spreading_factor_enable": [ 5, 6, 7, 8, 9, 10, 11, 12 ]},
        "chan_multiSF_0": { "enable": true, "radio": 1, "if": -300000 },
        "chan_multiSF_1": { "enable": true, "radio": 1, "if": -100000 },
        "chan_multiSF_2": { "enable": true, "radio": 1, "if": 100000 },
        "chan_multiSF_3": { "enable": true, "radio": 1, "if": 300000 },
        "chan_multiSF_4": { "enable": true, "radio": 0, "if": -300000 },
        "chan_multiSF_5": { "enable": true, "radio": 0, "if": -100000 },
        "chan_multiSF_6": { "enable": true, "radio": 0, "if": 100000 },
        "chan_multiSF_7": { "enable": true, "radio": 0, "if": 300000 },
        "chan_Lora_std":  { "enable": false, "radio": 1, "if": -200000, "bandwidth": 250000, "spread_factor": 7,
            "implicit_hdr": false, "implicit_payload_length": 17, "implicit_crc_en": false, "implicit_coderate": 1},
        "chan_FSK":       { "enable": false, "radio": 1, "if": 300000,  "bandwidth": 125000, "datarate": 50000 }
    },

    "gateway_conf": {
        "gateway_ID": "AA555A0000000000",
        /* change with default server address/ports */
        "server_address": "localhost",
        "serv_port_up": 1730,
        "serv_port_down": 1730,
        /* adjust the following parameters for your network */
        "keepalive_interval": 10,
        "stat_interval": 30,
        "push_timeout_ms": 100,
        "autoquit_threshold": 5,
        /* forward only valid packets */
        "forward_crc_valid": true,
        "forward_crc_error": false,
        "forward_crc_disabled": false
    }
}
```

### 3.3 868 profile

```json
{
    "SX130x_conf": {
        "com_type": "SPI",
        "com_path": "/dev/spidev0.0",
        "lorawan_public": true,
        "clksrc": 0,
        "antenna_gain": 0, /* antenna gain, in dBi */
        "full_duplex": false,
        "fine_timestamp": {
            "enable": false,
            "mode": "all_sf" /* high_capacity or all_sf */
        },
        "sx1261_conf": {
            "spi_path": "/dev/spidev0.1",
            "rssi_offset": -7, /* dB */
            "spectral_scan": {
                "enable": false,
                "freq_start": 867100000,
                "nb_chan": 8,
                "nb_scan": 2000,
                "pace_s": 10
            },
            "lbt": {
                "enable": false,
                "rssi_target": -70, /* dBm */
                "channels":[ /* 16 channels maximum */
                    { "freq_hz": 867100000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867300000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867500000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867700000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 867900000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 868100000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 868300000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 868500000, "bandwidth": 125000, "scan_time_us": 128,  "transmit_time_ms": 400 },
                    { "freq_hz": 869525000, "bandwidth": 125000, "scan_time_us": 5000, "transmit_time_ms": 4000 },
                    { "freq_hz": 868300000, "bandwidth": 250000, "scan_time_us": 128,  "transmit_time_ms": 400 }
                ]
            }
        },
        "radio_0": {
            "enable": true,
            "type": "SX1250",
            "single_input_mode": true,
            "freq": 867500000,
            "rssi_offset": -215.4,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": true,
            "tx_freq_min": 863000000,
            "tx_freq_max": 870000000,
            "tx_gain_lut":[
                {"rf_power": 12, "pa_gain": 1, "pwr_idx":  4},
                {"rf_power": 13, "pa_gain": 1, "pwr_idx":  6},
                {"rf_power": 14, "pa_gain": 1, "pwr_idx":  7},
                {"rf_power": 15, "pa_gain": 1, "pwr_idx":  8},
                {"rf_power": 16, "pa_gain": 1, "pwr_idx":  9},
                {"rf_power": 17, "pa_gain": 1, "pwr_idx": 11},
                {"rf_power": 18, "pa_gain": 1, "pwr_idx": 12},
                {"rf_power": 19, "pa_gain": 1, "pwr_idx": 14},
                {"rf_power": 20, "pa_gain": 1, "pwr_idx": 15},
                {"rf_power": 21, "pa_gain": 1, "pwr_idx": 16},
                {"rf_power": 22, "pa_gain": 1, "pwr_idx": 17},
                {"rf_power": 23, "pa_gain": 1, "pwr_idx": 18},
                {"rf_power": 24, "pa_gain": 1, "pwr_idx": 20},
                {"rf_power": 25, "pa_gain": 1, "pwr_idx": 20},
                {"rf_power": 26, "pa_gain": 1, "pwr_idx": 20},
                {"rf_power": 27, "pa_gain": 1, "pwr_idx": 20}
            ]
        },
        "radio_1": {
            "enable": true,
            "type": "SX1250",
            "single_input_mode": true,
            "freq": 868500000,
            "rssi_offset": -215.4,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": false
        },
        "chan_multiSF_All": {"spreading_factor_enable": [ 5, 6, 7, 8, 9, 10, 11, 12 ]},
        "chan_multiSF_0": { "enable": true, "radio": 1, "if": -400000 },
        "chan_multiSF_1": { "enable": true, "radio": 1, "if": -200000 },
        "chan_multiSF_2": { "enable": true, "radio": 1, "if": 0 },
        "chan_multiSF_3": { "enable": true, "radio": 0, "if": -400000 },
        "chan_multiSF_4": { "enable": true, "radio": 0, "if": -200000 },
        "chan_multiSF_5": { "enable": true, "radio": 0, "if": 0 },
        "chan_multiSF_6": { "enable": true, "radio": 0, "if": 200000 },
        "chan_multiSF_7": { "enable": true, "radio": 0, "if": 400000 },
        "chan_Lora_std":  { "enable": true, "radio": 1, "if": -200000, "bandwidth": 250000, "spread_factor": 7,
            "implicit_hdr": false, "implicit_payload_length": 17, "implicit_crc_en": false, "implicit_coderate": 1},
        "chan_FSK":       { "enable": true, "radio": 1, "if": 300000, "bandwidth": 125000, "datarate": 50000 }
    },

    "gateway_conf": {
        "gateway_ID": "AA555A0000000000",
        /* change with default server address/ports */
        "server_address": "localhost",
        "serv_port_up": 1730,
        "serv_port_down": 1730,
        /* adjust the following parameters for your network */
        "keepalive_interval": 10,
        "stat_interval": 30,
        "push_timeout_ms": 100,
        "autoquit_threshold": 5,
        /* forward only valid packets */
        "forward_crc_valid": true,
        "forward_crc_error": false,
        "forward_crc_disabled": false
    }
}
```

### 3.4 915 profile

```json
{
    "SX130x_conf": {
        "com_type": "SPI",
        "com_path": "/dev/spidev0.0",
        "lorawan_public": true,
        "clksrc": 0,
        "antenna_gain": 0, /* antenna gain, in dBi */
        "full_duplex": false,
        "fine_timestamp": {
            "enable": false,
            "mode": "all_sf" /* high_capacity or all_sf */
        },
        "sx1261_conf": {
            "spi_path": "/dev/spidev0.1",
            "rssi_offset": -15, /* dB */
            "spectral_scan": {
                "enable": false,
                "freq_start": 903900000,
                "nb_chan": 8,
                "nb_scan": 2000,
                "pace_s": 10
            },
            "lbt": {
                "enable": false /* LBT for 500 Khz channels is not supported */
            }
        },
        "radio_0": {
            "enable": true,
            "freq": 923500000,
            "single_input_mode": true,
            "rssi_offset": -215.4,
            "type": "SX1250",
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": true,
            "tx_freq_min": 923100000,
            "tx_freq_max": 924700000,
            "tx_gain_lut":[
                {"rf_power": 12, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 13, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 14, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 15, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 16, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 17, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 18, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 19, "pa_gain": 1, "pwr_idx":  1},
                {"rf_power": 20, "pa_gain": 1, "pwr_idx":  2},
                {"rf_power": 21, "pa_gain": 1, "pwr_idx":  3},
                {"rf_power": 22, "pa_gain": 1, "pwr_idx":  4},
                {"rf_power": 23, "pa_gain": 1, "pwr_idx":  6},
                {"rf_power": 24, "pa_gain": 1, "pwr_idx":  7},
                {"rf_power": 25, "pa_gain": 1, "pwr_idx":  8},
                {"rf_power": 26, "pa_gain": 1, "pwr_idx": 11},
                {"rf_power": 27, "pa_gain": 1, "pwr_idx": 12}
            ]
        },
        "radio_1": {
            "type": "SX1250",
            "enable": true,
            "single_input_mode": true,
            "freq": 924300000,
            "rssi_offset": -215.4,
            "rssi_tcomp": {"coeff_a": 0, "coeff_b": 0, "coeff_c": 20.41, "coeff_d": 2162.56, "coeff_e": 0},
            "tx_enable": false
        },
        "chan_multiSF_All": {"spreading_factor_enable": [ 5, 6, 7, 8, 9, 10, 11, 12 ]},
        "chan_multiSF_0": { "enable": true, "radio": 0, "if": -300000 },
        "chan_multiSF_1": { "enable": true, "radio": 0, "if": -100000 },
        "chan_multiSF_2": { "enable": true, "radio": 0, "if": 100000 },
        "chan_multiSF_3": { "enable": true, "radio": 0, "if": 300000 },
        "chan_multiSF_4": { "enable": true, "radio": 1, "if": -300000 },
        "chan_multiSF_5": { "enable": true, "radio": 1, "if": -100000 },
        "chan_multiSF_6": { "enable": true, "radio": 1, "if": 100000 },
        "chan_multiSF_7": { "enable": true, "radio": 1, "if": 300000 },
        "chan_Lora_std":  { "enable": true, "radio": 0, "if": 300000, "bandwidth": 500000, "spread_factor": 8,
            "implicit_hdr": false, "implicit_payload_length": 17, "implicit_crc_en": false, "implicit_coderate": 1 },
        "chan_FSK":       { "enable": false, "radio": 1, "if": 300000,  "bandwidth": 125000, "datarate": 50000 }
    },

    "gateway_conf": {
        "gateway_ID": "AA555A0000000000",
        /* change with default server address/ports */
        "server_address": "localhost",
        "serv_port_up": 1730,
        "serv_port_down": 1730,
        /* adjust the following parameters for your network */
        "keepalive_interval": 10,
        "stat_interval": 30,
        "push_timeout_ms": 100,
        "autoquit_threshold": 5,
        /* forward only valid packets */
        "forward_crc_valid": true,
        "forward_crc_error": false,
        "forward_crc_disabled": false
    }
}
```

## 4 Noise Scanning

Starting the noise floor scan with lora_pkt_fwd is just one usage, another usage is to use the `spectral_scan` command. **Note: Before using the `spectral_scan` command, you must first close the lora_pkt_fwd. **

Enter the util_spectral_scan directory, and execute the `./spectral_scan` command to start the background noise scan. The noise floor scanning function is very easy to operate, you only need to fill in the start frequency point and the number of channels to be scanned in the command parameters. The default step is 200000HZ, the number of samples is 2000, the rssi_offset 470 module compensation is -17dB, the 868 module compensation is -7dB, and the 915 module compensation is -15dB. The wider the bandwidth of the scan, the longer it will take. It is generally recommended to scan only 2MHz or 5MHz to cover the target working frequency band. **Note: Due to hardware reasons, the 470 module can only scan 470~490Mhz, the 868 module can only scan 862~876Mhz, and the 915 module can only scan 902~928Mhz. **

```
$> ./spectral_scan -f 471 -n 6
==
== Spectral Scan: freq_hz=471000000Hz, nb_channels=6, nb_scan=2000, rssi_offset=-11dB
==
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
INFO: using legacy timestamp
ARB: dual demodulation disabled for all SF
SX1261: PRAM version: SX1261 V2D 2D02
SX1261: PRAM version: SX1261 V2D 2D06
471000000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1792 208 0 0 0 
471200000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1746 254 0 0 0 
471400000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1758 242 0 0 0 
471600000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1789 211 0 0 0 
471800000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1758 242 0 0 0 
472000000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 34 1949 17 0 0 0 
Closing SPI communication interface
```

The scanned results show a horizontal peak wave, and the point with a higher peak wave has a higher noise floor ratio. First, the numbers in the first column of each row to `:` are the frequency points to be scanned. Starting from the back of `:`, each column of numbers represents the RSSI of the scanned noise floor, and there are 33 groups in total. The first value is rssi_offset compensation value -17dB, then each group has a difference of 4dB, and the RSSI of the last two groups is the same. As shown below, due to space issues, some meaningless values have been deleted in the middle.

```
#Frequency -17 -21 -25 -29 -33 ... -101 -105 -109 -113 -117 -121 -125 -129 -133 -137 -141 -141
471000000:  0   0   0   0   0        0    0    0    0    0    0    0  1792 208    0    0    0 # The noise floor of 471000000 frequency points is concentrated at -129dB
471200000:  0   0   0   0   0        0    0    0    0    0    0    0  1746 254    0    0    0 
471400000:  0   0   0   0   0  	     0    0    0    0    0    0    0  1758 242    0    0    0 
471600000:  0   0   0   0   0        0    0    0    0    0    0    0  1789 211    0    0    0 
471800000:  0   0   0   0   0        0    0    0    0    0    0    0  1758 242    0    0    0 
472000000:  0   0   0   0   0        0    0    0    0    0    0    34 1949  17    0    0    0 # 472000000 The noise floor is higher than other frequency points
```

For more configuration parameters of background noise scanning, please refer to the help manual `./spectral_scan -h`

```
$> ./spectral_scan -h
Library version information: Version: 2.1.0;
Available options:
 -h         Print this help
 -u         Set COM type as USB (default is SPI)
 -d [path]  Path to the main COM interface
            => default path: /dev/spidev0.0
 -D [path]  Path to the SX1261 SPI interface (not used for USB)
            => default path: /dev/spidev0.1
 -f <float> Scan start frequency, in MHz
 -n <uint>  Number of channels to scan
 -s <uint>  Number of scan points per frequency step [1..65535]
 -o <int>   RSSI Offset of the sx1261 path, in dB [-127..128]
 -l <char>  Log file name
```

## 5 Troubleshooting

### 5.1 Missing reset_lgw.sh script

When using lora_pkt_fwd or LoRa test command, the following error is prompted:

```
sh: 1: ./reset_lgw.sh: not found
```

When starting the lora_pkt_fwd or LoRa test command, first execute the reset_lgw.sh command in the current directory to reset the hardware, and then start the LoRa module. It will exit when it finds that there is no reset_lgw.sh command in the current directory.

The user should first switch to the directory where the lora_pkt_fwd or LoRa test command is located, then copy the `tools/reset_lgw.sh` command to the current directory, and then start the lora_pkt_fwd or LoRa test command.

### 5.2 Mod can't start properly

When lora_pkt_fwd starts, it prompts the following error. Then you have to check whether the LoRa module hardware is normal.

```
Opening SPI communication interface
Note: chip version is 0x00 (v0.0)
ERROR: Failed to set SX1250_0 in STANDBY_RC mode
ERROR: failed to setup radio 0
ERROR: [main] failed to start the concentrator
```

**Note: Before testing the LoRa module hardware, you must first close the lora_pkt_fwd. **

#### 5.2.1 Test spi (hardware related to master control and LoRa module master control)

Enter the libloragw directory and execute the `./test_loragw_com` command. If the following prompts are printed all the time, it means that the communication between the main control and the LoRa module main control is normal.

```
$> ./test_loragw_com
Beginning of test for loragw_com.c
Opening SPI communication interface
SX1302 version: 0x10
Cycle 0> did a 175-byte R/W on a data buffer with no error
Cycle 1> did a 1-byte R/W on a data buffer with no error
Cycle 2> did a 498-byte bulk R/W on a data buffer with no error
Cycle 3> did a 764-byte R/W on a data buffer with no error
Cycle 4> did a 1-byte R/W on a data buffer with no error
Cycle 5> did a 480-byte bulk R/W on a data buffer with no error
Cycle 6> did a 545-byte R/W on a data buffer with no error
Cycle 7> did a 1-byte R/W on a data buffer with no error
Cycle 8> did a 301-byte bulk R/W on a data buffer with no error
Cycle 9> did a 763-byte R/W on a data buffer with no error
Cycle 10> did a 1-byte R/W on a data buffer with no error
```

#### 5.2.2 Test SX1250 chip (LoRa RF front-end hardware)

Enter the libloragw directory and execute the `./test_loragw_com_sx1250` command. If the following prompts are printed all the time, it means that the communication between the SX1250 and the SX1302 chip is normal.

```
$> ./test_loragw_com_sx1250 
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
Radio0: get_status: 0xB2
Radio1: get_status: 0xB2
Cycle 0 > did a 4-byte R/W on a register with no error
Cycle 1 > did a 4-byte R/W on a register with no error
Cycle 2 > did a 4-byte R/W on a register with no error
Cycle 3 > did a 4-byte R/W on a register with no error
Cycle 4 > did a 4-byte R/W on a register with no error
Cycle 5 > did a 4-byte R/W on a register with no error
Cycle 6 > did a 4-byte R/W on a register with no error
Cycle 7 > did a 4-byte R/W on a register with no error
```

#### 5.2.3 Test SX1261 chip (noise floor scanning hardware)

Enter the libloragw directory and execute the `./test_loragw_com_sx1261` command. If the following prompts are printed all the time, it means that the communication between the main control and the SX1261 chip is normal.

```
$> ./test_loragw_com_sx1261 
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
SX1261: get_status: 0xA2
Cycle 0 > did a 4-byte R/W on a register with no error
Cycle 1 > did a 4-byte R/W on a register with no error
Cycle 2 > did a 4-byte R/W on a register with no error
Cycle 3 > did a 4-byte R/W on a register with no error
Cycle 4 > did a 4-byte R/W on a register with no error
Cycle 5 > did a 4-byte R/W on a register with no error
Cycle 6 > did a 4-byte R/W on a register with no error
Cycle 7 > did a 4-byte R/W on a register with no error
Cycle 8 > did a 4-byte R/W on a register with no error
Cycle 9 > did a 4-byte R/W on a register with no error
Cycle 10 > did a 4-byte R/W on a register with no error
```

#### 5.2.4 Test SX1302 (LoRa module master)

Enter the libloragw directory and execute the `./test_loragw_reg` command. If the following prompt is printed, it means that the SX1302 chip is normal.

```
$> ./test_loragw_reg
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
## TEST#1: read all registers and check default value for non-read-only registers
------------------
 TEST#1 PASSED
------------------

## TEST#2: read/write test on all non-read-only, non-pulse, non-w0clr, non-w1clr registers
------------------
 TEST#2 PASSED
------------------

Closing SPI communication interface
```

**If all the above tests pass, then the LoRa module hardware is normal.**

## 6 Hardware Application

### 6.1 Semtech HAL

This part will give the output power table for each band. Users should refer to these ta GW on server side.

Power level: LoRaWAN protocol power level; RF power: module actual output power

| PA   | Pwid | RF Power/dBm |        |        |
| ---- | ---- | ------------ | ------ | ------ |
|      |      | 490MHz       | 868MHz | 915MHz |
| 1    | 1    | 12.357       | 1.415  | 20.003 |
| 1    | 2    | 13.527       | 2.555  | 21.116 |
| 1    | 3    | 14.221       | 3.221  | 21.785 |
| 1    | 4    | 15.474       | 4.413  | 22.925 |
| 1    | 5    | 16.293       | 5.208  | 23.627 |
| 1    | 6    | 17.307       | 6.137  | 24.435 |
| 1    | 7    | 18.442       | 7.136  | 25.216 |
| 1    | 8    | 19.455       | 7.987  | 25.814 |
| 1    | 9    | 20.514       | 8.837  | 26.323 |
| 1    | 10   | 21.405       | 9.536  | 26.617 |
| 1    | 11   | 22.211       | 10.196 | 26.766 |
| 1    | 12   | 22.886       | 10.874 | 26.832 |
| 1    | 13   | 23.536       | 11.59  | 26.832 |
| 1    | 14   | 24.058       | 12.251 | 26.832 |
| 1    | 15   | 24.532       | 13.018 | 26.832 |
| 1    | 16   | 25.001       | 13.919 | 26.832 |
| 1    | 17   | 25.363       | 14.826 | 26.832 |
| 1    | 18   | 25.568       | 15.824 | 26.832 |
| 1    | 19   | 25.618       | 16.785 | 26.832 |
| 1    | 20   | 25.579       | 17.726 | 26.832 |
| 1    | 21   | 25.508       | 18.686 | 26.832 |
| 1    | 22   | 25.451       | 19.634 | 26.832 |

### 6.2 Reset sequence

Each time when powering up the RHF0M302 MiNi PCIE module, reset operation is compulsive. The input reset signal should be more than 1ms delay after VCC+3.3V stable.

![image-20230307121409420](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/5a9a9fdd62066b6a11bc72d1747dd854.png)

## 7 Reference Design

![image-20230307120108683](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/798ecb81e15dd1d870b80c5cde0adebf.png)

1. 220uF//220uF//100nF//100pF is strongly suggested to put as close as to the input pin (Pin1 and Pin2) of the module when you layout!
2. A RC filter (R=22R, C=10nF) is strongly suggested to be added for Reset connection。

### 7.1 Package information

![image-20230307120217518](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/31f61f86aacc034d3fe59ba952e9ca2b.png)

![image-20230307120227709](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/53878a81839a823d3cff33ed1939c765.png)

![image-20230307120238257](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/6ed38ecdfd5920fd9ed572fc03eb04f7.png)

### 7.2 Label

![image-20230307120322119](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/25b9a68f1bc9dfac7dddac7f110a9c98.png)

### 7.3 Outer packaging information

There will be a label with “RHF0M302-xxx” on the top side of the box. Box size is 150x90x42mm.

- RHF0M302-470B is the 470MHz band production.
- RHF0M302-868B is the 868MHz band production.
- RHF0M302-915B is the 915MHz band (902MHz to 928MHz) production.

![image-20230307120343963](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/65da7479a74b445c969d788e3be68a42.png)

![image-20230307120354272](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/62e8c6c4b9d8abe16019c8c8e74cafa3.png)

