---
title: 二次开发手册
date: 2023-02-08 10:10:10
permalink: /01/02/05/02/
---

## 1 简介

RHF2S209 由瑞兴恒方网络（深圳）有限公司自主研发和设计，是一台符合电信级要求的物联网LoRaWAN网关，该网关集成了LoRa、GPS、以太网、LTE、WiFi和备电锂电池（选配）。同时，该网关允许用户进行二次开发，方便集成第三方的LoRa服务用于连接到目标服务器。

## 2 硬件资源

- CPU：基于ARM Cortex-A7内核的处理器；

- 主频：650MHz；

- 内存：512Mbytes DDR3；

- Flash：8Gbytes eMMC；

- 硬件看门狗；

- 内部温度传感器；

- GPS模块；

- LoRaWAN模块X1；

- RTC实时时钟；

- WiFi/BT模块；
- 以太网；

- 内置备用电源（选配）；

- NL688-CN 4G模块（中国地区，RHF2S209xxx-470）：

LTE FDD: Band 1, Band 3, Band 5, Band 8, all bands with diversity 

LTE TDD: Band 34, Band 38, Band 39, Band 40, Band 41, all bands with diversity 

WCDMA: Band 1, Band 8, all bands with diversity 

TD-SCDMA: Band 34, Band 39 

GSM/GPRS/EDGE: 900 MHz/1800 MHz 

- NL688-EU 4G 模块（欧洲地区，RHF2S209xxx-868）：

LTE FDD: Band 1, Band 3, Band 5, Band 7, Band 8, Band 20, all bands with diversity 

WCDMA: Band 1, Band 5, Band 8, all bands with diversity 

GSM/GPRS/EDGE: 850 MHz/900 MHz/1800 MHz

- NL668-AM 4G 模块（北美地区， RHF2S209xxx-915）：

LTE FDD: Band 2, Band 4, Band 5, Band 12, Band 13, Band 17, Band 66, Band 71, all bands with diversity 

WCDMA: Band 2, Band 4, Band 5, all bands with diversity 

## 3 软件资源

- 基于Linux内核5.10.10版本；

- SPI驱动；

- I2C驱动；

- USB Host/Device驱动；

- LoRaWAN module驱动；

- 4G modem驱动，支持WCDMA/TD-LTE/GPRS/EDGE数据传输；

- GPS驱动，支持GPS精准授时；

- 以太网驱动；

- WiFi/BT驱动；

- DMA驱动；

- 按键驱动；

- LED驱动；

- 电源管理驱动；

- 内部温度传感器采集；

- 内部硬件看门狗

- RTC实时时钟管理；

- Bootloader；

- 支持镜像烧写；

## 4 调试接口

RHF2S209 提供了多种使用调试接口。

- web界面

- 串口调试
- SSH登录

本文档主要介绍串口调试和SSH登录。这里所谓的调试接口，其实是打开设备的命令终端进行调试。

不管是使用串口还是SSH登录设备，默认的用户名和密码如下：

用户：root

密码：risinghf

### 4.1 串口调试

在连接你的设备和电脑之前，请先安装FTDT USB转UART的驱动。打开设备盖子，使用一根USB转串口工具连接设备J4排针和电脑的USB端口，之后在你的电脑上会发现到一个COM端口。在ExtraPutty上选择“Serial”并填入正确的COM端口号和波特率115200，就可以成功连接到该设备上。

![image-20230216184550055](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/9f07832acf3a9318caa97060a4fd69d5.png)

然后输入用户“root”和密码“risinghf”即可登录设备。

![image-20230216184624937](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/9c6d9b693e790da58aa560bae29ce5d8.png)

### 4.2 SSH登录

#### 4.2.1 使用局域网DHCP的IP登录

将设备通过网线连接到局域网当中，使用上级路由器的DHCP服务查询到设备在局域网的IP地址。得到设备IP地址之后，使用Putty工具登录命令终端。

![image-20230216185227760](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/0f68889ea38831c99268da6a50140eb9.png)

#### 4.2.2 使用WiFi的IP登录

在电脑上扫描 WiFi 信号，找到 SSID 为 RHF2S209_XXXXXX 的设备并连接。电脑连接上设备后，默认IP 192.168.8.1。得到设备IP地址之后，使用Putty工具登录命令终端。WiFi 默认的 SSID 和密码:

SSID：RHF2S209_XXXXXX

密码：RisingHF_XXXXXX

注意：“XXXXXX”是以设备的 MAC 地址后 3bytes 结尾，若有字母则使用大写字母。

![image-20230216185103177](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/fbee7ae126865e43e506a0205f2c455c.png)

## 5 搭建开发环境

RHF2S209目前集成了loraserver、IoTSquare和本公司主自研发并且兼容标准packet_forwarder的LoRa服务程序，用户可以选择启动其中一个LoRa服务程序连接到相应服务器，或者开发新的LoRa服务程序集成到网关以连接第三方目标服务器。网关提供了交叉编译方式，帮助用户构建自己的二进制文件用于设备运行。

**本教程基于Ubuntu 20.04.5 LTS 64位操作系统搭建交叉编译环境**

### 5.1 下载交叉编译工具链

打开工具链下载页面https://www.st.com/en/embedded-software/stm32mp1dev.html#get-software，选择`Yocto_SDK` 3.0.0版本下载。

![image-20230216101637939](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/1129b0a3d243dc45ce7c14f4adf5b02f.png)

### 5.2 解压并安装交叉编译工具链

下载后得到一个`en.SDK-x86_64-stm32mp1-openstlinux-5.10-dunfell-mp1-21-03-31.tar.xz`文件。对它解压并安装。

```
PC $> tar xvf en.SDK-x86_64-stm32mp1-openstlinux-5.10-dunfell-mp1-21-03-31.tar.xz
PC $> chmod +x st-image-weston-openstlinux-weston-stm32mp1-x86_64-toolchain-3.1-openstlinux-5.10-dunfell-mp1-21-03-31.sh/st-image-weston-openstlinux-weston-stm32mp1-x86_64-toolchain-3.1-openstlinux-5.10-dunfell-mp1-21-03-31.sh
PC $> ./st-image-weston-openstlinux-weston-stm32mp1-x86_64-toolchain-3.1-openstlinux-5.10-dunfell-mp1-21-03-31.sh/st-image-weston-openstlinux-weston-stm32mp1-x86_64-toolchain-3.1-openstlinux-5.10-dunfell-mp1-21-03-31.sh
```

### 5.3 进入交叉编译环境

当执行成功后，进入交叉编译环境。

```
PC $> . /opt/st/stm32mp1/3.1-openstlinux-5.10-dunfell-mp1-21-03-31/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi
```

当进入交叉编译环境后，环境变量默认就包含了ARCH和CROSS_COMPILE变量。

### 5.4 测试交叉编译环境

测试gcc是否成功。在命令终端输入`arm-linux-gnueabihf-gcc -v`，如果输出以下内容，说明安装成功。

```
PC $> arm-linux-gnueabihf-gcc -v
Using built-in specs.
COLLECT_GCC=arm-linux-gnueabihf-gcc
COLLECT_LTO_WRAPPER=/opt/gcc-arm-8.2-2018.08-x86_64-arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/8.2.1/lto-wrapper
Target: arm-linux-gnueabihf
Configured with: /tmp/dgboter/bbs/bc-b1-2-11--rhe6x86_64/buildbot/rhe6x86_64--arm-linux-gnueabihf/build/src/gcc/configure --target=arm-linux-gnueabihf --prefix= --with-sysroot=/arm-linux-gnueabihf/libc --with-build-sysroot=/tmp/dgboter/bbs/bc-b1-2-11--rhe6x86_64/buildbot/rhe6x86_64--arm-linux-gnueabihf/build/build-arm-linux-gnueabihf/install//arm-linux-gnueabihf/libc --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --disable-libsanitizer --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/tmp/dgboter/bbs/bc-b1-2-11--rhe6x86_64/buildbot/rhe6x86_64--arm-linux-gnueabihf/build/build-arm-linux-gnueabihf/host-tools --with-mpfr=/tmp/dgboter/bbs/bc-b1-2-11--rhe6x86_64/buildbot/rhe6x86_64--arm-linux-gnueabihf/build/build-arm-linux-gnueabihf/host-tools --with-mpc=/tmp/dgboter/bbs/bc-b1-2-11--rhe6x86_64/buildbot/rhe6x86_64--arm-linux-gnueabihf/build/build-arm-linux-gnueabihf/host-tools --with-isl=/tmp/dgboter/bbs/bc-b1-2-11--rhe6x86_64/buildbot/rhe6x86_64--arm-linux-gnueabihf/build/build-arm-linux-gnueabihf/host-tools --with-arch=armv7-a --with-fpu=neon --with-float=hard --with-arch=armv7-a --with-pkgversion='GNU Toolchain for the A-profile Architecture 8.2-2018-08 (arm-rel-8.23)'
Thread model: posix
gcc version 8.2.1 20180802 (GNU Toolchain for the A-profile Architecture 8.2-2018-08 (arm-rel-8.23))
```

### 5.5 交叉编译

编译并运行hello world。

增加一个test.c文件

```
PC $> vi test.c
#include <stdio.h>

int main(int argc, char *argv[])
{
	printf("hello world!\n");
	return 0;
}
```

增加Makefile

```
PC $> vi Makefile
PROG = test
SRCS = test.c

CLEANFILES = $(PROG)

# Add / change option in CFLAGS and LDFLAGS
CFLAGS += -Wall
LDFLAGS += 

all: $(PROG)

$(PROG): $(SRCS)
	$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)

clean:
	rm -f $(CLEANFILES) $(patsubst %.c,%.o, $(SRCS))
```

**`$CC`是交叉编译工具链的变量，建议使用`$CC`编译，而非`arm-linux-gnueabihf-gcc`，否则可能会出现找不到依赖库等问题。**

**由于环境变量里已经有`CFLAGS`环境变量，因此Makefile使用`CFLAGS +=` 追加自己的选择。同理`LDFLAGS`也一样。**

交叉编译test.c

```
PC $> make
```

上传至设备运行

```
DEV $> ./test 
hello world!
```

## 6 编译sx1302_hal/packet forwarder

sx1302驱动库里同时包括了sx1302_hal和packet forwarder，因此只要编译sx1302_hal即可。

### 6.1 下载

下载sx1302驱动库。

```
PC $> git clone https://github.com/Lora-net/sx1302_hal.git
```

### 6.2 补丁

修改成交叉编译方式编译sx1302驱动库，以下是修改的补丁。

```
diff --git a/Makefile b/Makefile
index 687c12c..6e469e8 100644
--- a/Makefile
+++ b/Makefile
@@ -11,44 +11,44 @@ export
 all: libtools libloragw packet_forwarder util_net_downlink util_chip_id util_boot util_spectral_scan
 
 libtools:
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 libloragw: libtools
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 packet_forwarder: libloragw
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 util_net_downlink: libtools
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 util_chip_id: libloragw
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 util_boot: libloragw
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 util_spectral_scan: libloragw
-       $(MAKE) all -e -C $@
+       $(MAKE) all -C $@
 
 clean:
-       $(MAKE) clean -e -C libtools
-       $(MAKE) clean -e -C libloragw
-       $(MAKE) clean -e -C packet_forwarder
-       $(MAKE) clean -e -C util_net_downlink
-       $(MAKE) clean -e -C util_chip_id
-       $(MAKE) clean -e -C util_boot
-       $(MAKE) clean -e -C util_spectral_scan
+       $(MAKE) clean -C libtools
+       $(MAKE) clean -C libloragw
+       $(MAKE) clean -C packet_forwarder
+       $(MAKE) clean -C util_net_downlink
+       $(MAKE) clean -C util_chip_id
+       $(MAKE) clean -C util_boot
+       $(MAKE) clean -C util_spectral_scan
 
 install:
-       $(MAKE) install -e -C libloragw
-       $(MAKE) install -e -C packet_forwarder
-       $(MAKE) install -e -C util_net_downlink
-       $(MAKE) install -e -C util_chip_id
-       $(MAKE) install -e -C util_boot
-       $(MAKE) install -e -C util_spectral_scan
+       $(MAKE) install -C libloragw
+       $(MAKE) install -C packet_forwarder
+       $(MAKE) install -C util_net_downlink
+       $(MAKE) install -C util_chip_id
+       $(MAKE) install -C util_boot
+       $(MAKE) install -C util_spectral_scan
 
 install_conf:
-       $(MAKE) install_conf -e -C packet_forwarder
+       $(MAKE) install_conf -C packet_forwarder
 
 ### EOF
diff --git a/libloragw/Makefile b/libloragw/Makefile
index 881442f..fa0dfb3 100644
--- a/libloragw/Makefile
+++ b/libloragw/Makefile
@@ -8,10 +8,10 @@ include ../target.cfg
 
 ARCH ?=
 CROSS_COMPILE ?=
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
-CFLAGS := -O2 -Wall -Wextra -std=c99 -Iinc -I. -I../libtools/inc
+CFLAGS += -O2 -Wall -Wextra -std=c99 -Iinc -I. -I../libtools/inc
 
 OBJDIR = obj
 INCLUDES = $(wildcard inc/*.h) $(wildcard ../libtools/inc/*.h)
diff --git a/libtools/Makefile b/libtools/Makefile
index cf84988..321e0fd 100644
--- a/libtools/Makefile
+++ b/libtools/Makefile
@@ -4,10 +4,10 @@
 
 ARCH ?=
 CROSS_COMPILE ?=
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
-CFLAGS := -O2 -Wall -Wextra -std=c99 -Iinc -I.
+CFLAGS += -O2 -Wall -Wextra -std=c99 -Iinc -I.
 
 OBJDIR = obj
 INCLUDES = $(wildcard inc/*.h)
diff --git a/packet_forwarder/Makefile b/packet_forwarder/Makefile
index 2325a47..a244c58 100644
--- a/packet_forwarder/Makefile
+++ b/packet_forwarder/Makefile
@@ -24,10 +24,10 @@ RELEASE_VERSION := `cat ../VERSION`
 
 ### Constant symbols
 
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
-CFLAGS := -O2 -Wall -Wextra -std=c99 -Iinc -I. -I../libtools/inc
+CFLAGS += -O2 -Wall -Wextra -std=c99 -Iinc -I. -I../libtools/inc
 VFLAG := -D VERSION_STRING="\"$(RELEASE_VERSION)\""
 
 ### Constants for Lora concentrator HAL library
diff --git a/tools/payload_tools/Makefile b/tools/payload_tools/Makefile
index ed5e5fe..0ae0469 100644
--- a/tools/payload_tools/Makefile
+++ b/tools/payload_tools/Makefile
@@ -6,10 +6,10 @@ include ../../target.cfg
 
 ARCH ?=
 CROSS_COMPILE ?=
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
-CFLAGS := -O2 -Wall -Wextra -std=c99 -I. -I../../libtools/inc
+CFLAGS += -O2 -Wall -Wextra -std=c99 -I. -I../../libtools/inc
 
 ### linking options
 
diff --git a/util_boot/Makefile b/util_boot/Makefile
index 399db85..1d3d50d 100644
--- a/util_boot/Makefile
+++ b/util_boot/Makefile
@@ -16,19 +16,19 @@ ifeq '$(BUILD_MODE)' 'alpha'
   WARN_CFLAGS   :=
   OPT_CFLAGS    := -O0
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq '$(BUILD_MODE)' 'debug'
   $(warning /\/\/\/  Building in 'debug' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq  '$(BUILD_MODE)' 'release'
   $(warning /\/\/\/  Building in 'release' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2 -ffunction-sections -fdata-sections
   DEBUG_CFLAGS  :=
-  LDFLAGS       := -Wl,--gc-sections
+  LDFLAGS       += -Wl,--gc-sections
 else
   $(error BUILD_MODE must be set to either 'alpha', 'debug' or 'release')
 endif
@@ -41,9 +41,9 @@ APP_LIBS := -lloragw -lm -ltinymt32 -lrt
 LIB_PATH := ../libloragw
 
 ### Expand build options
-CFLAGS := -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CFLAGS += -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
 ### General build targets
 all: $(APP_NAME)
diff --git a/util_chip_id/Makefile b/util_chip_id/Makefile
index 50b110c..5bbe5cf 100644
--- a/util_chip_id/Makefile
+++ b/util_chip_id/Makefile
@@ -16,19 +16,19 @@ ifeq '$(BUILD_MODE)' 'alpha'
   WARN_CFLAGS   :=
   OPT_CFLAGS    := -O0
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq '$(BUILD_MODE)' 'debug'
   $(warning /\/\/\/  Building in 'debug' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq  '$(BUILD_MODE)' 'release'
   $(warning /\/\/\/  Building in 'release' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2 -ffunction-sections -fdata-sections
   DEBUG_CFLAGS  :=
-  LDFLAGS       := -Wl,--gc-sections
+  LDFLAGS       += -Wl,--gc-sections
 else
   $(error BUILD_MODE must be set to either 'alpha', 'debug' or 'release')
 endif
@@ -41,9 +41,9 @@ APP_LIBS := -lloragw -lm -ltinymt32 -lrt
 LIB_PATH := ../libloragw
 
 ### Expand build options
-CFLAGS := -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CFLAGS += -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
 ### General build targets
 all: $(APP_NAME)
diff --git a/util_net_downlink/Makefile b/util_net_downlink/Makefile
index 01829d2..cfb8fba 100644
--- a/util_net_downlink/Makefile
+++ b/util_net_downlink/Makefile
@@ -16,19 +16,19 @@ ifeq '$(BUILD_MODE)' 'alpha'
   WARN_CFLAGS   :=
   OPT_CFLAGS    := -O0
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq '$(BUILD_MODE)' 'debug'
   $(warning /\/\/\/  Building in 'debug' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq  '$(BUILD_MODE)' 'release'
   $(warning /\/\/\/  Building in 'release' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2 -ffunction-sections -fdata-sections
   DEBUG_CFLAGS  :=
-  LDFLAGS       := -Wl,--gc-sections
+  LDFLAGS       += -Wl,--gc-sections
 else
   $(error BUILD_MODE must be set to either 'alpha', 'debug' or 'release')
 endif
@@ -41,9 +41,9 @@ APP_LIBS := -lparson -lbase64 -lpthread
 LIB_PATH := ../libtools
 
 ### Expand build options
-CFLAGS := -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CFLAGS += -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
 ### General build targets
 all: $(APP_NAME)
diff --git a/util_spectral_scan/Makefile b/util_spectral_scan/Makefile
index 9322009..381c7e5 100644
--- a/util_spectral_scan/Makefile
+++ b/util_spectral_scan/Makefile
@@ -16,19 +16,19 @@ ifeq '$(BUILD_MODE)' 'alpha'
   WARN_CFLAGS   :=
   OPT_CFLAGS    := -O0
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq '$(BUILD_MODE)' 'debug'
   $(warning /\/\/\/  Building in 'debug' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2
   DEBUG_CFLAGS  := -g
-  LDFLAGS       :=
+  LDFLAGS       +=
 else ifeq  '$(BUILD_MODE)' 'release'
   $(warning /\/\/\/  Building in 'release' mode \/\/\/\)
   WARN_CFLAGS   := -Wall -Wextra
   OPT_CFLAGS    := -O2 -ffunction-sections -fdata-sections
   DEBUG_CFLAGS  :=
-  LDFLAGS       := -Wl,--gc-sections
+  LDFLAGS       += -Wl,--gc-sections
 else
   $(error BUILD_MODE must be set to either 'alpha', 'debug' or 'release')
 endif
@@ -41,9 +41,9 @@ APP_LIBS := -lloragw -lm -ltinymt32 -lrt
 LIB_PATH := ../libloragw
 
 ### Expand build options
-CFLAGS := -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
-CC := $(CROSS_COMPILE)gcc
-AR := $(CROSS_COMPILE)ar
+CFLAGS += -std=c99 $(WARN_CFLAGS) $(OPT_CFLAGS) $(DEBUG_CFLAGS)
+CC ?= $(CROSS_COMPILE)gcc
+AR ?= $(CROSS_COMPILE)ar
 
 ### General build targets
 all: $(APP_NAME)
```

### 6.3 编译

```
PC $> make
```

编译成功后，用户会得到几个二进制文件，其中packet_forwarder/lora_pkt_fwd文件比较重要，它是连接服务器的LoRa服务程序。

## 7 如何集成第三方LoRa服务

本文档使用foo-pktfwd作为例子，展示如何在设备里集成第三方LoRa服务。假设用户已经交叉编译成功lora_pkt_fwd。

### 7.1 关闭内置的LoRa服务

设备本身也内置了LoRa服务，但默认不会启动。如果用户启动了LoRa服务，那么请先关闭。

```
lora_service -s
```

### 7.2 安装LoRa服务程序

1. 网关在安装LoRa服务程序有目录规范。建议用户在/opt目录下创建自己的目录。如：

```
mkdir -p /opt/foo-pktfwd
```

2. 把lora_pkt_fwd和global_conf.json和local_conf.json上传至`/opt/foo-pktfwd`目录下，如果有更多的频率计划配置文件，则放到`/opt/foo-pktfwd/cfg`目录下。更多的目录结构信息请参考`/opt/pktfwd`。

3. 使用systemd的自启动服务来启动进程，通过在/lib/systemd/system目录下添加foo-pktfwd.service文件实现。**注意：用户如果以下service配置时，请把`#`和后面的注释去掉，否则可能无法正常工作。**

```
[Unit]
Description=Foo LoRa packet forwarder # 该服务器描述信息
After=initonce.service
After=network.target # 在网络服务后启动此服务

[Service]
Restart=always # 进程退出后重启的动作
RestartSec=60 # 配合Restart，进程退出60秒后重启
WorkingDirectory=/opt/foo-pktfwd # 进程的工作目录
ExecStartPre=/usr/local/sbin/web_select_lora_freq --name foo-pktfwd # 启动最终进程前先设置web界面状态
ExecStartPre=/usr/local/lora/lora_service -c /usr/local/lora/.lora_service.json -ffoo-pktfwd # 启动最终进程前先互斥其他LoRa服务进程
ExecStartPre=/usr/local/sbin/gwrst # 启动最终进程前先执行该进程
ExecStartPre=/usr/local/sbin/gwrst1 # 启动最终进程前先执行该进程
ExecStart=/opt/foo-pktfwd/lora_pkt_fwd # 最终启动的进程

[Install]
WantedBy=multi-user.target 
```

以上简单地介绍了一个LoRa服务进程如何启动。用户在foo-pktfwd.service里看到，之所以要启动最终的进程前要执行`/usr/local/lora/lora_service -c /usr/local/lora/.lora_service.json -ffoo-pktfwd`命令，是因为该命令就是起互斥其他进程的作用。-f参数意思是除了foo-pktfwd进程之外，所有的其它进程（这里的其它进程是注册到lora_service的进程）都停止。

### 7.3 注册LoRa服务互斥

```
lora_service -a '{"foo-pktfwd":["foo-pktfwd.service"]}'
```

注册LoRa服务互斥后，你的进程将与其他LoRa服务进程互斥，同一时刻只能启动一个LoRa服务，防止LoRa模组冲突。

### 7.4 注册web界面菜单

注册一个web界面LoRa服务菜单，这样用户就可以在web界面启动或关闭LoRa服务。

```
web_add_lora_service --name "foo-pktfwd" \
    --menu "foo-pktfwd" --index "99" \
    --wdir "/opt/foo-pktfwd" \
    --dir "/opt/foo-pktfwd/cfg" \
    --cfgs "/opt/foo-pktfwd/global_conf.json /opt/foo-pktfwd/local_conf.json"
```

--name：web界面名称，唯一标识。

--menu：web界面菜单标题。

--index：web界面顺序。

--wdir：工作目录。

--dif：可选择的频率配置文件目录。

--cfgs：使用频率配置文件，可为空。

### 7.5 系统自启动

当所有工作都完成后，执行以下命令开机自启动`foo-pktfwd` LoRa服务。

```
lora_service -r foo-pktfwd
```

## 8 软件接口

### 8.1 获取网关基本信息

网关提供了一些命令获取设备的基本信息，方便用户集成。

- 获取网关型号

```
$> get_model
RHF2S209BH8-470
```

- 获取固件版本

```
$> get_fw_ver 
1.0.0
```

- 获取制作固件日期

```
$> get_fw_date 
2023-01-03
```

- 获取硬件版本

```
$> get_hw_ver 
1.0
```

- 获取LoRa信道数，目前是8个信道

```
$> get_lora_channel_num 
8
```

- 获取网关是否支持全双工，`yes`代表支持全双工，`no`代表仅支持半双工

```
$> get_lora_full 
no
```

- 获取电池容量，`no`代表不支持电池

```
$> get_battery 
9.6V/3200mAh
```

- 获取linux内核版本

```
$> uname -r
5.10.10
```

- 获取系统本次运行时长

```
$> cat /proc/uptime
687.67 584.27
```

第一个字符代表网关目前运行时长，单位：秒。如上所示：代表网关持续运行了687.67秒。

- 获取当前系统时间和时区

```
$> timedatectl show
Timezone=Universal
LocalRTC=no
CanNTP=yes
NTP=yes
NTPSynchronized=yes
TimeUSec=Fri 2023-02-17 02:08:02 UTC
RTCTimeUSec=Fri 2023-02-17 02:08:03 UTC
```

Timezone：使用的时区，默认`Universal`。

TimeUSec：系统当前时间。

RTCTimeUSec：RTC模组时间。

- 获取以太网 MAC地址

```
$> cat /sys/class/net/eth0/address 
8c:f9:57:60:15:dc
```

- 获取以太网IP

```
$> ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 8C:F9:57:60:15:DC  
          inet addr:192.168.0.83  Bcast:192.168.1.255  Mask:255.255.254.0
          inet6 addr: 240e:3b3:30b0:d371::9b3/128 Scope:Global
          inet6 addr: fe80::8ef9:57ff:fe60:15dc/64 Scope:Link
          inet6 addr: 240e:3b3:30b0:d371:8ef9:57ff:fe60:15dc/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:38410 errors:0 dropped:12 overruns:0 frame:0
          TX packets:1522 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:7210187 (6.8 MiB)  TX bytes:152719 (149.1 KiB)
          Interrupt:53 Base address:0x8000
```

inet addr：以太网IP。

- 获取当前回传网络接口

```
$> netbackhaul 
eth0
```

- 获取版本修订记录

```
$> get_changelog 
## 1.0.0
- Initial version
```

### 8.2 备电锂电池（选配）

- 备电锂电池电压ADC采样

采样备电锂电池电压ADC，范围0～255。

```
$> /usr/local/battery/batadc.sh 
243
```

采集出来的ADC值通过公式`(ADC / 255.0 * 3.3) / (45.3 / (45.3 + 100))`换算对应的锂电池电压。如以上ADC值为243，那么此时锂电池的电压为`(243 / 255.0 * 3.3) / (45.3 / (45.3 + 100)) = 10.09V`。

不接电池时，ADC采样出来的范围为0～140。用户可以通过此范围判断是否接入了锂电池。

**注意：锂电池ADC采样不能太频繁，否则影响锂电池充电效率。建议每次采样间隔>=5分钟。**

- 备电锂电池电量

获取锂电池电量百分比。

```
$> /usr/local/battery/calpow
98
```

**注意：获取锂电池电量不能太频繁，否则影响锂电池充电效率。建议每次采样间隔>=5分钟。**

### 8.3 设置网络优先级

当设备存在着多个回传网络时，用户清楚哪个回传网络更稳定，可以选择自己的网络优先级。

- 查询网络优化级

```
$> netpriority 
eth
```

eth：以太网回传网络优化级最高。默认eth。

lte：4G回传网络优化级最高。

wifi：WiFI回传网络优化级最高。

- 设置最高网络优化级

```
$> netpriority eth
```

### 8.4 设置静态IP

当设备接网线时，默认通过DHCP方式获取上级路由器动态分配的IP地址。如果用户有设置静态IP的需求，使用`setip`命令设置静态IP。

以下是`setip`的帮助手册。

```
$> setip -h
Usage: setip [options]

Options:
  --help                  Show this help
  --mode      <MODE>      IP mode(dhcp, static)
  --addr      <ADDR>      IP addr
  --gateway   <GATEWAY>   IP GATEWAY
  --dns0      <DNS0>      nameserver0
  --dns1      <DNS1>      nameserver1

Examples:
  setip
  setip --mode dhcp
  setip --mode static --addr ADDR --gateway GATEWAY --dns0 DNS0 --dns1 DNS1
```

### 8.5 设置ntp服务器

设置NTP服务器，用户`setntp`命令管理自己的NTP服务器。最多只能同时有5个NTP服务器。

以下是`setntp`的帮助手册。

```
$> setntp -h
Usage: setntp [options] server

Options:
  --help                  Show this help
  --top     <TOPSERVER>   Top server

Examples:
  setntp SERVER
  setntp --top TOPSERVER
  setntp --top TOPSERVER SERVER
```

--top：把NTP服务器置顶，此NTP服务器优先级最高。

### 8.6 LTE

设备内嵌名为 lte 的系统服务, 此服务随系统默认开机启动。

特点：

1. 可以对sim卡进行自动识别并生成APN信息
2. 支持sim卡热插拔操作
3. 支持漫游功能

- 查看LTE拨号日志

```
$> cat /var/rlog/lte.log
```

具体日志分析请查看[LTE拨号日志]章节。

- 通过LTE接口确认是否拨号成功

```
$> ifconfig ppp0
ppp0      Link encap:Point-to-Point Protocol  
          inet addr:10.217.214.159  P-t-P:10.64.64.64  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3 
          RX bytes:52 (52.0 B)  TX bytes:246 (246.0 B)
```

当返回以上日志，代表拨号成功

- 复位4G模组

```
$> lterst
```

4G模组后复位后，大约需要等待20秒才能正常工作。

- 核实是否插入sim卡

```
$> ltesim
ltesim: lte sim start
ltesim: OK, SIM inserted
ltesim: lte sim done
```

- 获取当前网络信号质量

```
$> lterssi
lterssi: lte rssi start
lterssi: OK, -61
lterssi: lte rssi done
```

- 获取设备的IMEI码

```
$> lteimei
lteimei: lte imei start
lteimei: OK, 862819048837595
lteimei: lte imei done
```

- 获取sim卡IMSI

```
$> lteimsi
lteimsi: lte imsi start
carrier: �联�通�物�联�网 (China Unicom) IoT
carrier: �联�通�物�联�网 (China Unicom) IoT
carrier: �联�通�物�联�网 (China Unicom) IoT
lteimsi: OK, 460061185038354
lteimsi: lte imsi done
```

- 获取sim卡iccid

```
$> lteiccid
lteiccid: lte iccid start
lteiccid: OK, 89860619050022383540
lteiccid: lte iccid done
```

- 一键诊断LTE

```
$> ltediagnosis
ltediagnosis: lte diagnosis start
ltediagnosis: OK, lte modem normal
ltediagnosis: OK, usb bus normal
ltediagnosis: OK, SIM inserted
ltediagnosis: OK, rssi is -61
carrier: �联�通�物�联�网 (China Unicom) IoT
carrier: �联�通�物�联�网 (China Unicom) IoT
carrier: �联�通�物�联�网 (China Unicom) IoT
ltediagnosis: OK, imsi is 460061185038354
ltediagnosis: lte diagnosis done
```

- 打开lte服务

lte默认打开

```
$> systemctl enable lte && systemctl restart lte
```

- 关闭lte服务

```
$> systemctl disable lte; systemctl stop lte
```

- 查找APN

用户可以使用`selapn`命令，根据自己的sim卡APN信息查询设备是否已经存在该卡的APN，如果没有，通过addapn添加该卡的APN，使用`selapn --help`获取该命令的帮助信息。

```
$> selapn --help
Usage: selapn [options]

Options:
  --help                  Show this help
  --carrier <CARRIER>     Select carrier name
  --mcc <MCC>             Select carrier mcc
  --mnc <MNC>             Select carrier mnc
  --apn <APN>             Select carrier apn

Examples:
  selapn
  selapn --carrier CARRIER --mcc MCC --mnc MNC --apn APN
```

- 添加APN

设备系统内部已经包含了大多数全球主流运营商的 APN 配置。 但用户也可以通过`addapn` 命令来增加更多的 APN 配置信息。 使用`addapn --help`可以获取使用该命令的帮助信息。

```
$> addapn --help
Usage: addapn [options]

Options:
  --help                  Show this help
  --carrier <CARRIER>     Set carrier name
  --mcc <MCC>             Set carrier mcc
  --mnc <MNC>             Set carrier mnc
  --apn <APN>             Set carrier apn
  --user <USER>           Set apn user
  --pwd <PWD>             Set apn pwd

Examples:
  addapn --carrier CARRIER --mcc MCC --mnc MNC --apn APN --user USER --pwd PWD
  addapn --carrier CARRIER --mcc MCC --mnc MNC --apn APN
```

- 删除APN

用户想要删除多余的APN时，可以使用`delapn`命令，使用`delapn --help`获取该命令的帮助信息。

```
$> delapn --help
Usage: delapn [options]

Options:
  --help                  Show this help
  --carrier <CARRIER>     Delete carrier apn
  --mcc <MCC>             Delete carrier mcc
  --mnc <MNC>             Delete carrier mnc
  --apn <APN>             Delete apn

Examples:
  delapn --carrier CARRIER
  delapn --carrier CARRIER --mcc MCC --mnc MNC
  delapn --carrier CARRIER --apn APN
```

### 8.7 LoRa

- 复位LoRa

设备提供了硬件复位LoRa的命令，建议用户在使用LoRa之前，先使用硬件复位，可以避免程序执行失败等问题。

```
$> gwrst
```

### 8.8 底噪扫描

设备内置底噪分析引擎，该引擎可帮助用户在现场进行环境底噪扫描和分析，客户现场部署时提前发现干扰信号和噪声。以实现网络优化，避开强干扰的信道频率。**注意：在使用底噪扫描前，得先把LoRa服务关闭。**

底噪扫描功能操作非常简便，只需要命令参数填入起始频点和终止频点即可。默认的步进为200000HZ，采样次数为2000，rssi_offset RHF2S209xxx-470系列网关补偿为-17dB、RHF2S209xxx-868系列网关补偿为-7dB、rssi_offset RHF2S209xxx-915系列网关补偿为-15dB。扫描的带宽越宽，需要花费的时间就越长。一般建议只扫描2MHz或者5MHz以覆盖目标工作频段即可。**注意：硬件的原因导致RHF2S209xxx-470系列只能扫描470~490Mhz，RHF2S209xxx-868系列只能扫描862~876Mhz，RHF2S209xxx-915系列只能扫描902~928Mhz。**

```
$> cd /usr/local/lora/ && ./spectral_scan -f 471 -F 472
==
== Spectral Scan: start_freq_hz=471000000Hz, end_freq_hz=472000000HZ, step_hz=200000HZ, nb_channels=6, nb_scan=2000, rssi_offset=-11dB
==
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
INFO: using legacy timestamp
ARB: dual demodulation disabled for all SF
SX1261: PRAM version: SX1261 V2D 2D02
SX1261: PRAM version: SX1261 V2D 2D06
471000000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1792 208 0 0 0 
471200000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1746 254 0 0 0 
471400000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1758 242 0 0 0 
471600000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1789 211 0 0 0 
471800000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1758 242 0 0 0 
472000000: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 34 1949 17 0 0 0 
Closing SPI communication interface
```

扫描出来的结果程现出一个横向的峰波，峰波高的那个点底噪比较高。首先每行的第一列数字到`: `为扫描的频点。再从`:`后面开始，每列数字代表扫描到的底噪所在的RSSI，一共有33个组。第一个值为rssi_offset补偿值-17dB，然后每个组相差4dB，最后两组的RSSI是相同的。如下所示，由于篇幅的问题，中间删减了一些没意义的值。

```
# 频点     -17 -21 -25 -29 -33 ... -101 -105 -109 -113 -117 -121 -125 -129 -133 -137 -141 -141
471000000:  0   0   0   0   0        0    0    0    0    0    0    0  1792 208    0    0    0 # 471000000频点底噪集中在-129dB
471200000:  0   0   0   0   0        0    0    0    0    0    0    0  1746 254    0    0    0 
471400000:  0   0   0   0   0  	     0    0    0    0    0    0    0  1758 242    0    0    0 
471600000:  0   0   0   0   0        0    0    0    0    0    0    0  1789 211    0    0    0 
471800000:  0   0   0   0   0        0    0    0    0    0    0    0  1758 242    0    0    0 
472000000:  0   0   0   0   0        0    0    0    0    0    0    34 1949  17    0    0    0 # 472000000底噪比其它频点要高
```

底噪扫描更多的配置参数，请参考帮助手册`./spectral_scan -h`

```
$> ./spectral_scan -h
Library version information: Version: 1.0.0;
Available options:
 -h         Print this help
 -f <float> Scan start frequency, in MHz
 -F <float> Scan end frequency, in MHz
 -e <float> frequency step, in KHz
 -n <uint>  Number of channels to scan
 -s <uint>  Number of scan points per frequency step [1..65535]
 -o <int>   RSSI Offset of the sx1261 path, in dB [-127..128]
 -l <char>  Log file name
```

环境底噪是影响无线通信的一个重要指标参数。如果需要在现场架设和安装网关时，务必对现场的环境噪声做一个初步分析，以免高的噪声或者强的干扰影响通信距离和通信可靠性。我们希望环境噪声尽可能的低，但现实环境是不可能完全无干扰或者噪声的。一般建议环境噪底在-110dBm左右是比较理想的。通常也允许噪声最高不超过-100dBm，否则通信距离将严重受限。如果噪声在-95dBm以上，强烈建议更换工作频段以避开干扰噪声。

### 8.9 lora_service

网关集成了众多的LoRa服务进程，但是LoRa只允许一个进程占用它，也就是所有与LoRa有关的进程之间都是互斥的关系，但是进程与进程之间并没有关联，用户要怎么避免这个问题呢？

网关基于systemd封装了一个lora_service进程，用户把自己开发与LoRa相关进程用systemd做自启动管理，并把该服务注册到lora_service，那么该进程就可以与其他LoRa进程互斥。

以下用标准的packet_forwarder做例子讲解。packet_forwarder的相关的程序放在/opt/pktfwd，同时该目录也是它的工作目录，普通的启动方式无疑就是执行`./lora_pkt_fwd`，但是这样执行如果同一时刻有其他相关的LoRa服务进程在运行，会发生启动会失败或者无法接收数据等意料不到的问题。

所以建议使用systemd的自启动服务来启动进程，通过在/lib/systemd/system目录下添加xxx.service（xxx代表用户随意取的名字，但是不能跟其他文件重复）文件实现。以下讲解标准packet_forwarder进程的服务文件的启动服务实现方式。

 ```
 $> cat /lib/systemd/system/pktfwd.service
 [Unit]
 Description=Semtech LoRa packet forwarder # 该服务器描述信息
 After=initonce.service
 After=network.target # 在网络服务后启动此服务
 
 [Service]
 Restart=always # 进程退出后重启的动作
 RestartSec=60 # 配合Restart，进程退出60秒后重启
 WorkingDirectory=/opt/pktfwd # 进程的工作目录
 ExecStartPre=/usr/local/sbin/web_select_lora_freq --name pktfwd # 启动最终进程前先设置web界面状态
 ExecStartPre=/usr/local/lora/lora_service -c /usr/local/lora/.lora_service.json -fpktfwd # 启动最终进程前先互斥其他LoRa服务进程
 ExecStartPre=/usr/local/sbin/gwrst # 启动最终进程前先执行该进程
 ExecStartPre=/usr/local/sbin/gwrst1 # 启动最终进程前先执行该进程
 ExecStart=/opt/pktfwd/lora_pkt_fwd # 最终启动的进程
 
 [Install]
 WantedBy=multi-user.target 
 ```

以上简单地介绍了一个LoRa服务进程如何启动。用户在pktfwd.service里看到，之所以要启动最终的进程前要执行`/usr/local/lora/lora_service -c /usr/local/lora/.lora_service.json -fpktfwd`命令，是因为该命令就是起互斥其他进程的作用。-f参数意思是除了pktfwd进程之外，所有的其它进程（这里的其它进程是注册到lora_service的进程）都停止。

使用`lora_service -h`可以查看相关的使用说明。

```
$> lora_service -h

Available options:
 -h                   print this help
 -c <file>            load config file
 -a <str>             add(replace) lora service
 -d <str>             del lora service
 -l                   list lora service
 -q                   query use lora service
 -s [str]             stop lora service
 -f [str]             filter stop lora service
 -t [str]             temporary stop lora service
 -r <str>             restart/start lora service
 -T <str>             temporary restart/start lora service

Example:
 lora_service -a '{"service_name":["service1.service","service2.service",...]}'
 lora_service -d service_name
 lora_service -l
 lora_service -q
 lora_service -s [service_name]
 lora_service -f [service_name]
 lora_service -t [service_name]
 lora_service -r service_name
 lora_service -T service_name
```

- 查看注册的LoRa服务

```
$> lora_service -l
loraserver
        loraserver-bridge.service
        loraserver-pktfwd.service
pktfwd
        pktfwd.service
iotsquare
        iotsquare-pktfwd.service
```

系统默认注册了pktfwd、iotsquare和loraserver三个LoRa服务。

pktfwd使用pktfwd.service配置托管LoRa服务。同理，iotsquare使用iotsquare-pktfwd.service配置托管LoRa服务，而loraserver使用loraserver-bridge.service和loraserver-pktfwd.service两个配置托管LoRa服务。

- 注册LoRa服务

```
$> lora_service -a '{"service_name":["service1.service","service2.service",...]}' 
```

service_name和xxx.service不能与已注册的LoRa服务相同。

- 注销LoRa服务

```
lora_service -d "service_name"
```

- 查询正在使用的服务

```
$> lora_service -q
service_name
```

- 停止LoRa服务

```
$> lora_service -s
```

用户无需知道正在使用哪个LoRa服务也能停止。

- 跳过此LoRa服务，关闭其他的LoRa服务

```
lora_service -f"service_name"
```

- 启动指定的LoRa服务

```
lora_service -r "service_name"
```

以上的service_name代表用户自定义的LoRa服务名称。

### 8.10 温度传感器

设备内部集成一个高精度的温度传感器， 可以实时监控设备内部环境温度。 你可以使用命令`get_temp` 实时查询内部温度，但是用户集成到程序里执行，尽量控制在大于一分钟采集一次周期里，因为系统有多个监控进程使用了该命令，频繁使用会导致设备CPU占用率高。

```
$> get_temp
22.06
```

### 8.11 修改时区

- 查询系统支持的时区

```
/usr/bin/timedatectl list-timezones
```

- 修改时区

```
$> timedatectl set-timezone Asia/Shanghai
```

如：修改成`Asia/Shanghai`时区

### 8.12 系统启动只执行一次

`/etc/initonce.d/`目录下的命令开机只执行一次。如果执行成功（命令返回0）时，系统会把此命令删除，下次开机将不会再执行此命令。如果执行失败（命令返回非0）时，系统下次启动仍然会再执行。适合用户开机只执行一次的配置。

### 8.13 报告网络状态接口

当回传网络的路由路径发生改变时，系统会执行`/etc/route-call.d`目录所有命令。其中暴露了`ROUTE_BEFOR`和`ROUTE_CURR`两个变量，分别代表之前的路由路径和当前的路由路径。适合用户监控网络路由路径是否发生改变。

### 8.14 报告外部电源状态接口

当外部电源状态发生改变时，系统会执行`/etc/power-call.d/`目录所有命令。其中暴露了`NAME`和`STATE`两个变量，分别代表外部电源名称和当前状态。适合用户监控外部电源状态是否发生改变。

### 8.15 报告备电锂电池状态接口

当备电锂电池状态发生改变时，系统会执行`/etc/battery-call.d/`目录所有命令。其中暴露了`BAT_BEFOR`和`BAT_CURR`两个变量，分别代表备电锂电池之前状态和当前状态。适合用户监控备电锂电池状态是否发生改变。

因为备电锂电池使用轮询的方式捕捉状态改变，所以每次开机都会执行一次`/etc/battery-call.d/`目录所有命令，而且如果改变状态时间间隔短，有可能会丢失本次状态记录。外部电源使用中断方式捕捉状态改变，因此不会出现像锂电池这样的情况。

### 8.16 WiFi

WiFi AP服务主要给用户用于近场无线调试。

- 打开WiFi AP服务

WiFi AP服务默认打开。

```
$> openap
```

- 关闭WiFi AP服务

如果用户出于安全考虑，不想让人连接WiFi AP，可以使用`closeap`命令关闭。

```
$> closeap
```

- 显示WiFi SSID

WiFi SSID默认是显示。

```
$> waphidden --hidden 0
```

- 隐藏WiFi SSID

如果用户出于安全考虑，不想WiFi SSID被人扫描出来，可以使用`waphidden`命令隐藏。

```
$> waphidden --hidden 1
```

- 获取WiFi SSID

```
$> wapgetssid
RHF2S209_6015DC
```

- 修改WiFi AP配置

用户通过`wapset`修改WiFi AP的配置，包括网关地址、SSID、密码和是否隐藏SSID。

以下是`wapset`的帮助手册。

```
$> wapset -h
Usage: wapset [options]

Options:
  --help                  Show this help
  --addr     <ADDRESS>    Set gateway address
  --ssid     <SSID>       Set ssid
  --pwd      <PWD>        Set wpa_passphrase
  --hidden   <HIDE>       Hidden ssid(0 not hidden, 1 hidden)

Examples:
  wapset --ssid SSID --pwd PWD --hidden 0
  wapset --addr ADDRESS --ssid SSID --pwd PWD  --hidden 0
```

### 8.17 web界面服务

web界面服务是设备内置的web界面。使用设备的IP，通过浏览器即可打开web界面。具体的使用方式参考《使用手册》的[内置web界面]章节。

- 打开web服务

web服务默认打开。

```
$> openweb
```

- 关闭web服务

如果用户出于安全考虑，不想让人登录web界面，可以使用`closeweb`命令关闭。

```
$> closeweb
```

### 8.18 调试串口

- 打开调试串口

调试串口默认打开。

```
$> openserial
```

- 关闭调试串口

如果用户出于安全考虑，不想让人通过调试串口登录命令终端，可以使用`closeserial`命令关闭。

```
$> closeserial
```

### 8.19 ssh管理

- 打开ssh

ssh默认打开。

```
$> openssh
```

- 关闭ssh

如果用户出于安全考虑，不想让人通过ssh登录命令终端，可以使用`closessh`命令关闭。

```
$> closessh
```

## 9 设备日志

RHF2S209 有两个日志输出目录，分别是/var/log 和/var/rlog 目录。这两个日志目录区别主要体现在设备重启后，日志是否被清空。/var/log 目录主要保存系统日志，设备重启后日志会被清空，俗称非持久化日志，保存输出日志较多并且不是特别重要的日志。/var/rlog 目录主要保存关键进程相关的日志，设备重启不受影响，俗称持久化日志，保存输出日志不多并且特别重要、方便以后查看设备的状态的日志。

### 9.1 /var/log（非持久化日志）

非持久化日志最多保存246M，当大于246M时，再也写不进去日志，但不会影响程序使用。当然设备会定期切割日志，保证设备非持久化日志不会大于246M。

#### 9.1.1 内核日志

/var/log/kern.log，记录了内核运行的日志，包含内核运行的状态信息，用户可以用于分析设备系统的运行状况。

#### 9.1.2 syslog日志

/var/log/syslog，记录内核日志、systemd日志和进程标准错误输出等日志，几乎包括了系统所有的日志。

#### 9.1.3 pktfwd日志

/var/log/pktfwd.log，记录LoRa的日志（如果pktfwd未开启日志或进程未启动，日志可能不存在）。**注意：日志不是实时记录。**

##### 9.1.3.1 stat包

以下日志属于pktfwd stat包，pktfwd会定期上报stat包。用户可以通过global_conf.json或者local_conf.json文件的gateway_conf.stat_interval选项修改stat包上报周期。

```
7 2022-11-15T00:00:17.264461Z   PKTFWD:929    time 49354473, frame PUSH_DATA, 02, 4026, 00, 8CF957FFFE6017E5, {"stat":{"time":"2022-11-15 00:00:17 GMT","lati":0,"long":0,"alti":0,"rxnb":6,"rxok":6,"rxfw":6,"ackr":100,"dwnb":6,"txnb":6,"gtss":2}} // 上报一个stat包
6 2022-11-15T00:00:17.266221Z   PKTFWD:402    PUSH_ACK (4026) received in 2 ms
7 2022-11-15T00:00:17.266294Z   PKTFWD:945    time 49354475, frame PUSH_ACK, 02, 4026, 01
```

stat json对象包含网关的状态，具有以下字段：

![image-20230216181442321](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/aa9b249081aff5c47e2dfce5a3939f7d.png)

##### 9.1.3.2 LoRaWAN上下行数据包

以下日志属于LoRaWAN上下行数据。其中rxpk json包属于上行数据包，data属于节点应用数据经过加密和base64编码得到的数据。用户主要关心tmst、freq、rssi和lsnr字段。txpk json包属于下行数据包，用户可以根据tmst（单位：ms）字段判断上行数据所对应服务器下发的下行数据，因为上行的tmst+1s=下行的tmst，如：rxpk和txpk是属于一对上下行数据，因为2105654642+1000000=2106654642。用户主要关心tmst和freq字段。

```
7 2022-11-15T00:00:14.949014Z   PKTFWD:929    time 49352158, frame PUSH_DATA, 02, 4025, 00, 8CF957FFFE6017E5, {"rxpk":[{"jver":1,"time":"2022-11-15T00:00:14.877267Z","tmst":2105654642,"rfch":0,"chan":5,"freq":484.9,"mid":8,"stat":1,"modu":"LORA","datr":"SF7BW125","codr":"4/5","rssic":-49,"foff":-315,"rssi":-49,"lsnr":13.5,"size":14,"data":"gMuKxwCAZ/oIkAM5Q+I="}]} // 接收到LoRaWAN上行数据包
6 2022-11-15T00:00:14.951076Z   PKTFWD:402    PUSH_ACK (4025) received in 2 ms
7 2022-11-15T00:00:14.951147Z   PKTFWD:945    time 49352160, frame PUSH_ACK, 02, 4025, 01
7 2022-11-15T00:00:15.297317Z   PKTFWD:1057   PULL_RESP (4A39) push ok
7 2022-11-15T00:00:15.297470Z   PKTFWD:945    time 49352506, frame PULL_RESP, 02, 4A39, 03, {"txpk":{"imme":false,"tmst":2106654642,"freq":505.3,"rfch":0,"powe":20,"modu":"LORA","datr":"SF7BW125","codr":"4/5","ipol":true,"size":12,"ncrc":true,"data":"YMuKxwCgtvgKimii","brd":0,"ant":0,"nhdr":false}}
7 2022-11-15T00:00:15.297914Z     JITQ:776    enqueue: pkt 2106654642, pre 31500, post 41000, type 0, now 2106075279, delta 579363, qos 5
7 2022-11-15T00:00:15.297990Z     JITQ:799    jit queue packets 1 (beacons: 0, ceacons: 0, downlinks: 1)
7 2022-11-15T00:00:15.298069Z   PKTFWD:929    time 49352507, frame TX_ACK, 02, 4A39, 05, 8CF957FFFE6017E5, {"txpk_ack":{"error":"NONE","jiterr":"NONE"}}
7 2022-11-15T00:00:15.856316Z     JITQ:789    dequeue: pkt 2106654642, pre 31500, post 41000, type 0, now 2106629201, delta 25441, qos 5
7 2022-11-15T00:00:15.856414Z     JITQ:799    jit queue packets 0 (beacons: 0, ceacons: 0, downlinks: 0)
7 2022-11-15T00:00:15.856450Z       RF:1202   LoRa0: lgw_send, enter 2106629201, exit 2106633681, packet 2106654642, cost 4480, diff 20961, api 4460us, lock 4463us, peek 1us, deq 5us, gps 3us, poll 5047, dly 5039
```

rxpk json对象包含网关的上行数据，具有以下字段：

![image-20230216182016162](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/9eb8e912bfdb30efcc7deea9f5924da3.png)

txpk json对象包含网关的下行数据，具有以下字段：

![image-20230216182058738](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/4874761c2b27350f95bb7d7e7590e385.png)

#### 9.1.4 rhf-bridge日志

/var/log/bridge.log，记录rhf-birdge的日志（如果rhf-birdge未开启日志或进程未启动，日志可能不存在）。

#### 9.1.5 其它日志

系统还包括了访问、验证、切割、web界面等日志，这里就不一一说明。

#### 9.1.6 查看指定服务日志

### 9.2 /var/rlog（持久化日志）

持久化日志保存大小与eMMC剩余空间相等，一般都可以保存5～6Gbytes，但是当eMMC剩余空间不足时会影响程序正常使用，因此保存持久化日志要谨慎。当然设备会定期切割日志，保证设备持久化日志不会占用太多eMMC。

#### 9.2.1 以太网日志

/var/rlog/eth.log，当以太网、4G和WiFi这三个网络组件的网络状态发生改变时，系统会生成一行日志，记录三个组件当时的网络状态。

```
[2020-09-20 10:44:24+00:00]->[eth0: connected, wlan0: disconnected, wlan1: disconnected]
[2023-02-13 10:42:09+00:00]->[eth0: connected, ppp0: connected, wlan1: disconnected]
[2023-02-13 10:44:59+00:00]->[eth0: connected, ppp0: connected, wlan1: disconnected]
[2023-02-13 10:45:02+00:00]->[eth0: connected, ppp0: connected, wlan1: disconnected]
[2023-02-14 03:06:57+00:00]->[eth0: disconnected, ppp0: connected, wlan1: disconnected]
[2023-02-14 03:24:11+00:00]->[eth0: connected, ppp0: connected, wlan1: disconnected]
[2023-02-15 04:24:17+00:00]->[eth0: connected, wlan1: disconnected, ppp0: disconnected]
[2023-02-15 04:24:23+00:00]->[eth0: connected, ppp0: connected, wlan1: disconnected]
[2023-02-16 05:24:25+00:00]->[eth0: connected, wlan1: disconnected, ppp0: disconnected]
[2023-02-16 05:24:29+00:00]->[eth0: connected, ppp0: connected, wlan1: disconnected]
```

#### 9.2.2 LTE拨号日志

/var/rlog/lte.log，记录LTE拨号全部日志。

##### 9.2.2.1 拨号成功示例

当日志提示"dial success"代表拨号成功。

```
[2020-09-20 10:44:17+00:00]->[ltestart: start dial]
[2023-02-13 10:42:00+00:00]->[ltestart: OK, SIM inserted]
[2023-02-13 10:42:00+00:00]->[ltestart: OK, 89860619050022383540]
[2023-02-13 10:42:00+00:00]->[automatically operators mode]
[2023-02-13 10:42:01+00:00]->[ltestart: APN information: �联�通�物�联�网 (China Unicom) IoT,460,06,unim2m.bjm2mapn,,] // 拨号APN详细信息
timeout set to 15 seconds
abort on (DELAYED)
abort on (BUSY)
abort on (ERROR)
abort on (NO DIALTONE)
abort on (NO CARRIER)
send (AT^M)
expect (OK)
AT^M^M
OK
 -- got it

send (AT+CREG?^M)
expect (OK)
^M
AT+CREG?^M^M
+CREG: 0,1^M
^M
OK
 -- got it

send (AT+COPS?^M)
expect (OK)
^M
AT+COPS?^M^M
+COPS: 0,0,"CHN-UNICOM",7^M
^M
OK
 -- got it

send (AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M) // unim2m.bjm2mapn为拨号APN
expect (OK)
^M
AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M^M
OK
 -- got it

send (ATD*99#^M)
expect (CONNECT)
^M
ATD*99#^M^M
CONNECT
 -- got it

send (^M)
Serial connection established.
Using interface ppp0
Connect: ppp0 <--> /dev/ltemodem
Could not determine remote IP address: defaulting to 10.64.64.64
not replacing default route to eth0 [192.168.0.1]
local  IP address 10.212.96.167 // 获取到运营商IP代表拨号成功，该IP是不固定的
remote IP address 10.64.64.64
primary   DNS address 210.22.70.3
secondary DNS address 210.22.84.3
[2023-02-13 10:42:07+00:00]->[ltestart: dial success] // 提示拨号成功
[2023-02-13 10:42:08+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -57] // 当前网络的信号质量
```

##### 9.2.2.2 不插sim卡拨号

```
[2023-02-16 08:36:19+00:00]->[ltestart: start dial]
[2023-02-16 08:37:20+00:00]->[ltestart: start dial]
[2023-02-16 08:38:20+00:00]->[ltestart: start dial]
[2023-02-16 08:39:21+00:00]->[ltestart: start dial]
[2023-02-16 08:40:21+00:00]->[ltestart: start dial] // 定期轮循开始拨号
```

##### 9.2.2.3 找不到APN

```
[2023-02-16 09:17:29+00:00]->[ltestart: start dial]
[2023-02-16 09:17:30+00:00]->[ltestart: OK, SIM inserted]
[2023-02-16 09:17:30+00:00]->[ltestart: OK, 89860619050022383540]
[2023-02-16 09:17:30+00:00]->[automatically operators mode]
[2023-02-16 09:17:31+00:00]->[ltestart: NG, unsupport 2 bits mnc sim card, 460, 06] // 找不到APN
[2023-02-16 09:17:31+00:00]->[ltestart: NG, unsupport 3 bits mnc sim card, 460, 061] 
```

##### 9.2.2.4 sim 卡无费用/使用错误APN/设备所在的位置无运营商网络/sim卡有绑定功能

```
[2023-02-16 08:58:41+00:00]->[ltestart: start dial]
[2023-02-16 08:58:43+00:00]->[ltestart: OK, SIM inserted]
[2023-02-16 08:58:44+00:00]->[ltestart: OK, 89860619050022383540]
[2023-02-16 08:58:44+00:00]->[automatically operators mode]
[2023-02-16 08:58:45+00:00]->[ltestart: APN information: �联�通�物�联�网 (China Unicom) IoT,460,06,unim2m.bjm2mapn,,]
timeout set to 15 seconds
abort on (DELAYED)
abort on (BUSY)
abort on (ERROR)
abort on (NO DIALTONE)
abort on (NO CARRIER)
send (AT^M)
expect (OK)
AT^M^M
OK
 -- got it

send (AT+CREG?^M)
expect (OK)
^M
AT+CREG?^M^M
+CREG: 0,1^M
^M
OK
 -- got it

send (AT+COPS?^M)
expect (OK)
^M
AT+COPS?^M^M
+COPS: 0^M
^M
OK
 -- got it

send (AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M)
expect (OK)
^M
AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M^M
OK
 -- got it

send (ATD*99#^M)
expect (CONNECT)
^M
ATD*99#^M^M
CONNECT
 -- got it

send (^M)
Serial connection established.
Using interface ppp0
Connect: ppp0 <--> /dev/ltemodem
Modem hangup
Connection terminated. // 第一次拔号，失败
[2023-02-16 08:58:50+00:00]->[ltestart: modem hangup]
[2023-02-16 08:58:51+00:00]->[ltestart: Retry [0] pppd return 16]
timeout set to 15 seconds
abort on (DELAYED)
abort on (BUSY)
abort on (ERROR)
abort on (NO DIALTONE)
abort on (NO CARRIER)
send (AT^M)
expect (OK)
AT^M^M
OK
 -- got it

send (AT+CREG?^M)
expect (OK)
^M
AT+CREG?^M^M
+CREG: 0,1^M
^M
OK
 -- got it

send (AT+COPS?^M)
expect (OK)
^M
AT+COPS?^M^M
+COPS: 0^M
^M
OK
 -- got it

send (AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M)
expect (OK)
^M
AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M^M
OK
 -- got it

send (ATD*99#^M)
expect (CONNECT)
^M
ATD*99#^M^M
CONNECT
 -- got it

send (^M)
Serial connection established.
Using interface ppp0
Connect: ppp0 <--> /dev/ltemodem
Modem hangup
Connection terminated. // 第二次拔号，失败
[2023-02-16 08:58:56+00:00]->[ltestart: modem hangup]
[2023-02-16 08:58:56+00:00]->[ltestart: Retry [1] pppd return 16]
timeout set to 15 seconds
abort on (DELAYED)
abort on (BUSY)
abort on (ERROR)
abort on (NO DIALTONE)
abort on (NO CARRIER)
send (AT^M)
expect (OK)
AT^M^M
OK
 -- got it

send (AT+CREG?^M)
expect (OK)
^M
AT+CREG?^M^M
+CREG: 0,1^M
^M
OK
 -- got it

send (AT+COPS?^M)
expect (OK)
^M
AT+COPS?^M^M
+COPS: 0^M
^M
OK
 -- got it

send (AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M)
expect (OK)
^M
AT+CGDCONT=1,"IP","unim2m.bjm2mapn"^M^M
OK
 -- got it

send (ATD*99#^M)
expect (CONNECT)
^M
ATD*99#^M^M
CONNECT
 -- got it

send (^M)
Serial connection established.
Using interface ppp0
Connect: ppp0 <--> /dev/ltemodem
Modem hangup
Connection terminated.  // 第三次拔号，失败
[2023-02-16 08:59:00+00:00]->[ltestart: modem hangup]
[2023-02-16 08:59:00+00:00]->[ltestart: Retry [2] pppd return 16]
[2023-02-16 08:59:00+00:00]->[ltestart: APN dial failure] // 每个APN有三次拔号机会，三次失败后才会选择下一个APN
```

##### 9.2.2.5 信号质量

当拨号成功后，每隔15分钟记录当前网络的信号质量。

```
[2023-02-16 05:24:28+00:00]->[ltestart: dial success]
[2023-02-16 05:24:28+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 05:39:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 05:54:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 06:09:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 06:24:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 06:39:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 06:54:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 07:09:29+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 07:24:30+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53]
[2023-02-16 07:39:30+00:00]->[ltestart: CHN-UNICOM's 7 rssi is -53] // 当前网络信号质量为-53dbm
```

#### 9.2.3 电源日志

/var/rlog/pow.log，当外部电源和备电锂电池发生插入或拔出时，便会记录一行操作日志。

因为备电锂电池使用轮询的方式捕捉状态改变，所以每次开机都会生成一行日志，而且如果改变状态时间间隔短，有可能会丢失本次状态记录。外部电源使用中断方式捕捉状态改变，因此不会出现像锂电池这样的情况。

```
[2023-02-13 10:43:45+00:00]->[INFO: plug the battery]
[2023-02-13 10:46:44+00:00]->[INFO: plug the battery]
[2023-02-16 07:49:04+00:00]->[INFO: unplug the battery]
[2023-02-16 07:54:07+00:00]->[INFO: plug the battery]
[2023-02-16 07:56:44+00:00]->[INFO: disconnect to external power supply]
[2023-02-16 07:56:51+00:00]->[INFO: connect to external power supply]
```

#### 9.2.4 运行日志

/var/rlog/runtime.log，记录设备开机时刻和这次开机一共运行时长。它保存的日志格式`[开机时间]->[系统运行时长(单位:秒)]`，每隔5分钟刷新一次“系统运行时长”，所以误差是 0~-5min。

```
[2023-02-13 10:43:45+00:00]->[157.87] // 该日志记录着设备在2023-02-13 10:43:45+00:00左右开机，运行了157.87秒后设备关机
[2023-02-13 10:46:46+00:00]->[247848.18] // 如果该日志是文件最后一行日志，说明当前设备在2023-02-13 10:46:46+00:00左右开机，当前已经运行了247848.18秒，在未来的5分钟内，该值会被刷新
```

#### 9.2.5 温度日志

/var/rlog/temp.log，记录设备盒子里的温度，每隔15分钟采集一次温度。

```
[2023-02-13 10:43:46+00:00]->[null] // 设备启动后第一个的温度采集值是“null”，主要用于分割上次启动采集的温度和这次启动采集的温度
[2023-02-13 10:43:46+00:00]->[28.19]
[2023-02-13 10:46:47+00:00]->[null]
[2023-02-13 10:46:47+00:00]->[28.62]
[2023-02-13 11:01:48+00:00]->[29.69]
[2023-02-13 11:16:48+00:00]->[29.69]
[2023-02-13 11:31:49+00:00]->[29.56]
[2023-02-13 11:46:50+00:00]->[29.38]
```

**注意：一般盒子里的温度比当前环境温度高8°C左右。**

#### 9.2.6 检测日志

/var/rlog/det.log，异常检测日志（如果设备没有发生过异常，日志可能不存在）。当设备检测到设备有异常后，记录一行日志，并且执行相应的异常处理。

```
[2023-02-16 07:59:00+00:00]->[The ppp0 cannot ping the server, re-establish] // 如果4G拨号成功了，但是尝试ping指定服务器10次，一次都ping不成功，那么将会重新再拨号。常见于物联网卡有白名单功能，需要添加/opt/rhf-bridge/sdk_conf.json的mqtt_server到白名单。
[2023-02-16 08:04:11+00:00]->[The ppp0 cannot ping the server, system ready reboot] // 当插入了sim卡，但是一直都拨号不成功，当拨号不成功1000次时，那么会重启设备。常见于sim卡无费用/设备所在的位置无运营商网络/sim卡有绑定功能。
[2023-02-18 08:07:23+00:00]->[dhcp failed, system ready reboot] // 接入网线后，无法正确获取IP地址。
```

## 10  故障排除

### 10.1 LoRa服务进程冲突

LoRa模组是属于独占资源，网关只能被一个程序占用LoRa模组。若同时多个程序使用LoRa模组，会导致网关LoRa模组出现无法预料的问题。因此，不管在使用、测试时，都要确保LoRa服务模组只被一个程序运行。

目前网关系统集成的启动LoRa服务的程序有：

- packet_forwarder
- iotsquare
- loraserver
- LoRa测试程序

#### 10.1.1 ps

使用`ps -ef | grep -E "lora_pkt_fwd|pktfwd|loragw|spectral_scan"`命令查看系统是否有LoRa服务相关的程序。

- lora_pkt_fwd是packet_forwarder进程关键字

- pktfwd是iotsquare、loraserver进程关键字

- loragw是LoRa测试进程关键字

若LoRa模组被占用，将返回两条（其中一条是自身命令的记录）或者以上的记录。用户根据返回的进程关键字判断出系统正在被哪个进程被执行，如下所示，LoRa模组正被iotsquare服务占用（具体怎么关闭服务请参考设备的用户手册）。

![image-20230216173541129](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/589fdeed067778debb46b452fb7fa6be.png)

#### 10.1.2 自主研发的pktfwd

自主研发的pktfwd在启动时，会检查LoRa模组是否已经被使用。若被使用，就会返回错误并退出。因此，可以使用它来检查LoRa模组是否已经被使用了。
执行命令：`/opt/pktfwd/lora_pkt_fwd`
若LoRa模组被占用，将输出如下图所示的错误，其中（PID xxxx）是LoRa模组被xxxx进程占用了。使用`kill -9 xxxx`杀死进程。如果是使用systemd服务启动的进程，那么得关闭LoRa服务才行（具体怎么关闭服务请参考设备的用户手册），否则过段时间会再次被占用。

![image-20230216173721470](https://risinghf-wiki.oss-cn-shenzhen.aliyuncs.com/upload/img/7fdc2f09c7d34acca9fd46896c756d96.png)

#### 10.1.3 lora_service

网关自定义了lora_service命令托管网关LoRa服务进程，可以确保一次只运行一个LoRa服务进程，同时也可以使用该命令查询、关闭正在运行的LoRa进程。
查询命令：lora_service -q
关闭命令：lora_service -s
更多选项请查看帮助手册：lora_service -h
**注意：此命令无法查询非lora_service托管LoRa服务进程是否在运行，如：LoRa测试进程。**

### 10.2 LoRa模组无法正常启动

当lora_pkt_fwd/pktfwd在启动时，提示以下错误。那么得排查一下LoRa模组硬件是否正常。

```
    _/_/_/    _/_/_/    _/_/_/  _/_/_/  _/      _/    _/_/_/  _/    _/  _/_/_/
   _/    _/    _/    _/          _/    _/_/    _/  _/        _/    _/  _/     
  _/_/_/      _/      _/_/      _/    _/  _/  _/  _/  _/_/  _/_/_/_/  _/_/_/  
 _/    _/    _/          _/    _/    _/    _/_/  _/    _/  _/    _/  _/       
_/    _/  _/_/_/  _/_/_/    _/_/_/  _/      _/    _/_/_/  _/    _/  _/        
Create pid file successfully
Search directory /opt/rhf-bridge
Read configuration file /opt/rhf-bridge/global_conf.json
Read configuration file /opt/rhf-bridge/local_conf.json
Read configuration file /opt/rhf-bridge/cal_conf.json
6 2023-02-16T09:46:50.655577Z   PKTFWD:200    tx timeout 100ms, pull data period 30s, keep alive timeout 150s
6 2023-02-16T09:46:50.665383Z       RF:339    LoRa0: Concentrator starting...
7 2023-02-16T09:46:50.665431Z       RF:349    LoRa0: Radio A, 485000000
7 2023-02-16T09:46:50.665463Z       RF:349    LoRa0: Radio B, 485800000
6 2023-02-16T09:46:50.665493Z       RF:359    LoRa0: CH 0, 485500000, -300000
6 2023-02-16T09:46:50.665523Z       RF:359    LoRa0: CH 1, 485700000, -100000
6 2023-02-16T09:46:50.665553Z       RF:359    LoRa0: CH 2, 485900000, 100000
6 2023-02-16T09:46:50.665582Z       RF:359    LoRa0: CH 3, 486100000, 300000
6 2023-02-16T09:46:50.665611Z       RF:359    LoRa0: CH 4, 484700000, -300000
6 2023-02-16T09:46:50.665640Z       RF:359    LoRa0: CH 5, 484900000, -100000
6 2023-02-16T09:46:50.665669Z       RF:359    LoRa0: CH 6, 485100000, 100000
6 2023-02-16T09:46:50.665697Z       RF:359    LoRa0: CH 7, 485300000, 300000
3 2023-02-16T09:46:51.793205Z       RF:369    LoRa0: Concentrator error
2 2023-02-16T09:46:51.793407Z    APPPF:84     rf start failed // 无法启动LoRa模组
```

**注意：在测试LoRa模组硬件前，得先把LoRa服务关闭。**

#### 10.2.1 测试spi（主控与LoRa模组主控相关硬件）

执行 `cd /usr/local/lora/ && ./test_loragw_com`命令，如果一直打印以下提示，那么代表主控与LoRa模组主控通讯正常。

```
$> cd /usr/local/lora/ && ./test_loragw_com
Beginning of test for loragw_com.c
Opening SPI communication interface
SX1302 version: 0x10
Cycle 0> did a 175-byte R/W on a data buffer with no error
Cycle 1> did a 1-byte R/W on a data buffer with no error
Cycle 2> did a 498-byte bulk R/W on a data buffer with no error
Cycle 3> did a 764-byte R/W on a data buffer with no error
Cycle 4> did a 1-byte R/W on a data buffer with no error
Cycle 5> did a 480-byte bulk R/W on a data buffer with no error
Cycle 6> did a 545-byte R/W on a data buffer with no error
Cycle 7> did a 1-byte R/W on a data buffer with no error
Cycle 8> did a 301-byte bulk R/W on a data buffer with no error
Cycle 9> did a 763-byte R/W on a data buffer with no error
Cycle 10> did a 1-byte R/W on a data buffer with no error
```

#### 10.2.2 测试SX1250芯片（LoRa射频前端硬件）

执行 `cd /usr/local/lora/ && ./test_loragw_com_sx1250`命令，如果一直打印以下提示，那么代表SX1250与SX1302芯片通讯正常。

```
$> cd /usr/local/lora/ && ./test_loragw_com_sx1250 
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
Radio0: get_status: 0xB2
Radio1: get_status: 0xB2
Cycle 0 > did a 4-byte R/W on a register with no error
Cycle 1 > did a 4-byte R/W on a register with no error
Cycle 2 > did a 4-byte R/W on a register with no error
Cycle 3 > did a 4-byte R/W on a register with no error
Cycle 4 > did a 4-byte R/W on a register with no error
Cycle 5 > did a 4-byte R/W on a register with no error
Cycle 6 > did a 4-byte R/W on a register with no error
Cycle 7 > did a 4-byte R/W on a register with no error
```

#### 10.2.3 测试SX1261芯片（底噪扫描硬件）

执行 `cd /usr/local/lora/ && ./test_loragw_com_sx1261`命令，如果一直打印以下提示，那么代表主控与SX1261芯片通讯正常。

```
$> cd /usr/local/lora/ && ./test_loragw_com_sx1261 
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
SX1261: get_status: 0xA2
Cycle 0 > did a 4-byte R/W on a register with no error
Cycle 1 > did a 4-byte R/W on a register with no error
Cycle 2 > did a 4-byte R/W on a register with no error
Cycle 3 > did a 4-byte R/W on a register with no error
Cycle 4 > did a 4-byte R/W on a register with no error
Cycle 5 > did a 4-byte R/W on a register with no error
Cycle 6 > did a 4-byte R/W on a register with no error
Cycle 7 > did a 4-byte R/W on a register with no error
Cycle 8 > did a 4-byte R/W on a register with no error
Cycle 9 > did a 4-byte R/W on a register with no error
Cycle 10 > did a 4-byte R/W on a register with no error
```

#### 10.2.4 测试SX1302（LoRa模组主控）

执行 `cd /usr/local/lora/ && ./test_loragw_reg`命令，如果打印以下提示，那么代表SX1302芯片正常。

```
$> cd /usr/local/lora/ && ./test_loragw_reg
Opening SPI communication interface
Note: chip version is 0x10 (v1.0)
## TEST#1: read all registers and check default value for non-read-only registers
------------------
 TEST#1 PASSED
------------------

## TEST#2: read/write test on all non-read-only, non-pulse, non-w0clr, non-w1clr registers
------------------
 TEST#2 PASSED
------------------

Closing SPI communication interface
```

**如果以上所有的测试都通过，那么LoRa模组硬件是正常。**

### 10.3 测试GPS

用户开启packet_forwarder beacon，但是节点切换不了class B模式。这时得确认是否GPS信号质量差。

**注意：在测试GPS前，得先把LoRa服务关闭。**

#### 10.3.1 测试GPS模组

执行`gps -t`，返回OK代表主控与GPS模组通讯正常，NG代表硬件出现了问题。

```
$> gps -t
OK
```

**注意：如果用户没有关闭LoRa服务，同时LoRa服务正在使用GPS模组，那么可能会返回NG。**

#### 10.3.2 GPS获取地理位置

```
$> gps --gl 1
22.547961,N,113.936117,E
```

#### 10.3.3 GPS获取授时和卫星数

```
$> gps -v
b5620120100048946207d03e0500ca08120732000000a6f2
GSP INFO: [atomic time:1360923901], [utc time:2023-02-20T10:24:42], [latitude:22.547981], [longitude:113.936074], [altitude:36.7], [svnum:6]
$GPRMC,102443.00,A,2232.87874,N,11356.16432,E,0.855,,200223,,,A*7E
$GPVTG,,T,,M,0.855,N,1.584,K,A*23
$GPGGA,102443.00,2232.87874,N,11356.16432,E,1,06,1.26,36.6,M,-2.7,M,,*73
$GPGSA,A,3,19,17,30,03,14,06,,,,,,,2.78,1.26,2.48*09
$GPGSV,3,1,12,01,17,038,,03,42,068,18,04,00,120,,06,45,255,18*7D
$GPGSV,3,2,12,07,05,173,,09,03,151,,11,10,235,,14,86,099,20*7F
$GPGSV,3,3,12,17,47,352,22,19,32,314,22,30,25,205,16,40,20,257,*76
$GPGLL,2232.87874,N,11356.16432,E,102443.00,A,A*6E
```

如果想要正常使用packet_forwarder beacon功能，`svnum`至少得5颗星或以上。

**以上所有的测试都通过，那么网关的GPS模组正常并且GPS信号质量好。**
